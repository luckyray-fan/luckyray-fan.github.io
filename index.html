<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="只能自己努力找乐子了">
    <meta name="keywords" content>
    <meta name="author">
    <meta name="copyright">
    <title>_(:з」∠)_ | luckyray</title><link rel="shortcut icon" href="/favicons.ico">
    <link rel="stylesheet" href="/css/index.css?version=1.6.1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1">
    <link rel="dns-prefetch" href="https://cdn.staticfile.org">
    <link rel="dns-prefetch" href="https://cdn.bootcss.com">
    <link rel="dns-prefetch" href="https://creativecommons.org">
    <script>
      var GLOBAL_CONFIG = {
        root: '/',
        algolia: undefined,
        localSearch: undefined,
        copy: {
          success: '复制成功',
          error: '复制错误',
          noSupport: '浏览器不支持'
        }
      }
    </script>
  </head>
  <body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i>
    <div id="sidebar">
      <div class="author-info">
        <div class="author-info__avatar text-center"><img src="/img/avatar.png"></div>
        <div class="author-info__name text-center"></div>
        <div class="author-info__description text-center">只能自己努力找乐子了</div>
        <hr>
        <div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">23</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a>
        </div>
      </div>
    </div>
    <nav id="nav" style="background-image: url(http://img.luckyray.cn/896653.jpg)">
      <div id="page-header"><span class="pull-left"> <a id="site-name" href="/">luckyray</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div>
      <div id="site-info">
        <div id="site-title">luckyray</div>
        <div id="site-sub-title">_(:з」∠)_</div>
        <div id="site-social-icons"><a class="social-icon" href="https://github.com/yoshiro_fan"><i class="fa-github fa"></i></a>
        </div>
      </div>
    </nav>
    <div id="content-outer">
      <div class="layout" id="content-inner">
        <div class="recent-post-item article-container"><a class="article-title" href="/2020/02/02/nodejs-app-picpick/">nodejs 批量反向查询并下载原图</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-02
          </time>
          <div class="content"><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>采用了队列式的下载, 保证下载不停滞, 当搜索出的所有结果下载完成后才移动被搜索的图片<br>下面是第一批的结果, 截了部分图片, 另外这个是多次运行项目最后得到的结果(前期编写不完善), 从100张图片搜索共得到313张, 有4张图片无法查找到结果, 原因和改进都会在下方讲述</p>
<blockquote>
<p>现已经由250+图找到了700+图, 注意, 目前没有普适性(使用了七牛云, 虽然也写了 smms 但是没有使用), 项目仅供参考, <a href="https://github.com/luckyray-fan/picpick/tree/master" target="_blank" rel="noopener">项目地址</a></p>
</blockquote>
<p><img src="/image/picpick-1.png" alt="部分图片"></p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这个项目和之前手机上传文件一样, 是有个明确的需求的, 因为经常用手机刷telegram, 平时积累了许多图片, 但是这些图片往往像素不高, 所以就得一个个查询原图下载</p>
<h2 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h2><p>目的流程:  筛选出不清晰的图片 -&gt; 利用图片搜索结果 -&gt; 下载</p>
<ul>
<li>筛选: 如果图片大小小于300k就搜索</li>
<li>搜索: 查询 sauce, ascii2d, iqdb</li>
<li>下载: 解析查询结果, 使用 socket 代理建立连接下载(毕竟不少图片是 pixiv 和 twitter)</li>
</ul>
<blockquote>
<p>关于网站查询结果<br>sauce: pixiv, twitter 居多, 能找到很多其他网站<br>ascii: pixiv, twitter<br>iqdb: 各大图库, 例如 danbooru<br>tineye: 没能解析, 使用了 cloud 防护, 尝试了 puppteer 后放弃了, 可以手动访问然后请求带上 cookie 试试</p>
</blockquote>
<h2 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h2><p>下方编写整个项目遇到的问题和解决的方法, 如何找到bug, 如何增强功能等</p>
<h3 id="建立整个项目基础"><a href="#建立整个项目基础" class="headerlink" title="建立整个项目基础"></a>建立整个项目基础</h3><p>google了一下相关的查询方案, 参考了这个项目 <a href="https://github.com/Tsuk1ko/CQ-picfinder-robot/tree/master/modules" target="_blank" rel="noopener">CQ-picfinder-robot</a>, 决定使用 sauce 和 ascii 来查询, 然后项目编写一个配置文件, 项目的请求采用 Axios, 用代理的方式为 httpsAgent</p>
<h3 id="获取需要查询的图片"><a href="#获取需要查询的图片" class="headerlink" title="获取需要查询的图片"></a>获取需要查询的图片</h3><p>在配置文件里写好路径, 图片文件路径 <code>source</code>, 检测不清晰后移动的路径 <code>lowQuality</code>, 查询完成后移动出来的路径 <code>out</code>, 然后调用node 文件系统的 api, 使用 <code>statsync</code> 判断文件还是文件夹, <code>file-type</code> 判断文件类型</p>
<p>之前决定用 sauce 来查询, 利用 <code>url</code> 字段传递想要查询的图片, 那么现在就需要一个中继的服务器, 一开始浏览了 smms, imgur 等图床, 后面决定使用早就实名好的七牛云来上传</p>
<p><strong>遇到的问题</strong></p>
<ul>
<li>file-type 是异步的: 使用 await 获取最终返回值, 将原本同步的函数加上 async</li>
<li>七牛云 api 是回调的方式: 这个和整体清一色 await 不一致, 为了捕获到最后执行完成然后将结果返回给外部, 使用 <code>setInterval</code> 来查询 <code>flag</code> 的状态, 如果为真, 意味着上传完成执行 <code>Promise</code> 回调中的 <code>resolve</code>, 将值传给外部<br><img src="/image/picpick-2.png" alt="回调捕捉"></li>
</ul>
<h3 id="建立查询方式"><a href="#建立查询方式" class="headerlink" title="建立查询方式"></a>建立查询方式</h3><p>使用 sauce, 利用相似度来判断第一步, 若未成功用 ascii 的色合检索来接力, 如果 ascii 也失败了的话使用 iqdb 来进行最后一步查询</p>
<ul>
<li><strong>如何查询的</strong>:<ul>
<li>sauce: 注册账号后可以查看其 api 说明, 当然也可以看看 github 上相关的说明, 这个是直接发请求然后解析返回的值就好了, 从返回的 <code>limit</code> 字段可以明确知道有多少的限制</li>
<li>ascii: 发送请求然后解析返回的页面, 可以将返回的 url 中的 color 替换为 bovw 再请求一次, 也就是获得特征检索的结果, 详细描述我写在了 github 的 ascii 文件中</li>
<li>iqdb: 发送请求解析返回的页面</li>
</ul>
</li>
<li><strong>错误处理</strong>: 因为采取的都是 await 的写法, 捕捉到错误后将错误打印然后返回一个指定的值, 外界得到返回的值判断是否成功</li>
<li><strong>sauce 429</strong>:<ul>
<li><strong>代理池</strong>, 编写 proxyPool, 解析各大公开代理的网站<ul>
<li>这些网站对于爬虫似乎限制挺大的, 因此加了出现错误延时再试的机制, 访问也都带了 <code>user-agent</code> 和 <code>refer</code>, 对于使用了 cloud 防护的需要手动获取 cookie, 更多可以查到国内可用 ip 的解析网站可以去 github 找一找</li>
<li>测试 ip 的可用性是通过访问能<a href="https://icanhazip.com/" target="_blank" rel="noopener">返回请求的ip的网站</a>, 判断与现在使用的代理 ip 是否相同</li>
<li>部分代理网站和测试代理 ip 时连接上但是迟迟不返回, 一开始依照惯例给了 timeout, 然后发现了这个超时的区别不同, 分别有连接和读取超时, 于是采用 axios 的 cancel, 如果超过一定时间直接取消掉, 详细可以看 <a href="https://juejin.im/post/5de0ddbf51882523467752b8" target="_blank" rel="noopener">ECONNRESET VS ETIMEDOUT</a></li>
<li>注意不要使用 axios cancel 掉的请求捕捉错误的值来赋值, 它的 valueof 方法似乎有点问题, 会递归然后溢出</li>
</ul>
</li>
<li>连接重试, 每一次换一个 ip 进行请求, 这里没有使用本地 ip 的请求, 都是由 ssr 和 公开代理提供的</li>
</ul>
</li>
<li><strong>iqdb 返回image type error</strong>: iqdb 不支持某些格式的图片, 查看出错的图片, 发现后缀名和 exif 信息不匹配, 于是使用了七牛云的图片处理接口, 所有图片强制转换为 jpg</li>
</ul>
<h3 id="下载机制"><a href="#下载机制" class="headerlink" title="下载机制"></a>下载机制</h3><p>根据之前反向搜索查到的网址, 解析网站获取图片地址, 然后依次下载, 如果解析失败, 使用 iqdb 专搜图库再来一次, 如果下载失败, 进行重试(看看有没有这个需求, 尚未完善)</p>
<ul>
<li><strong>直接爬取 pixiv</strong>: github 上搜索了一下, 有相关的库, 但是在此之前我已经找到了别人提供的 api 了<ul>
<li><strong>发现这个 api 有时超时</strong>, 又找到了 pixiv.cat, 做了后手, 保证解析</li>
</ul>
</li>
<li><strong>下载会卡住</strong>:<ul>
<li>同文件系统建立连接需要使用到线程池, node 默认的线程池大小为 4 条, 发出网络链接却不会用到, 所以查询很快, 但是下载很容易卡住, 详细可以看 <a href="https://juejin.im/post/5b1e55cbe51d45067e6fcb84" target="_blank" rel="noopener">什么东西会占线程池</a>, <a href="https://stackoverflow.com/questions/22644328/when-is-the-thread-pool-used" target="_blank" rel="noopener">when is thread pool used</a><ul>
<li>使用下载队列的模式, 固定最大同时可以进行连接的数量为 4, 用 setTimeout 事件循环来判断是否处理完毕</li>
<li>可以多加几个线程, 不过 windows 需要带参数启动, 我没试</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存同步</strong>: js 不会出现这个函数执行到一半跳到另一个函数上, 所以不用写信号量什么的</li>
</ul>
<h3 id="错误提醒-日志打印"><a href="#错误提醒-日志打印" class="headerlink" title="错误提醒, 日志打印"></a>错误提醒, 日志打印</h3><p>为了查找出可能的 bug, 建立一个完善的错误打印机制是很有必要的, 使用了 <code>progress</code> 来检测下载进度, <code>log4js</code> 打印日志, 同时每张图片的查询都会伴随一个图片的信息对象, 每个查询的结果都会保存在其中, 在最后提示出来</p>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2020/01/03/computer-network/">计算机网络</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-03
          </time>
          <div class="content"><h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>计算机网络: 一组通过单一技术相互链接的自主计算机集合</li>
</ul>
<h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><ul>
<li>依据传输模式<ul>
<li>单播: 只有一个发送方与一个接收方, 也叫点到点链路</li>
<li>广播: 任何人发出的数据包能被任何机器收到, 但是根据数据包首部的地址字段判断是否应答</li>
<li>多播/组播: 将数据包发给一组机器</li>
</ul>
</li>
<li>依据尺度<ul>
<li>局域网: 局部地区的私有网络<ul>
<li>无线: 每台计算机有无线解调器与天线来与ap, 基站, 无线路由器通讯, 这些装置负责无线计算机之间与计算机和互联网的中级</li>
<li>有线: 以太网 IEEE 802.3 最常见, 通过点到点拓扑连接到交换机, 交换机判断数据包地址给相应的计算机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="服务接口协议"><a href="#服务接口协议" class="headerlink" title="服务接口协议"></a>服务接口协议</h3><ul>
<li>服务: 由原语说明, 用户可通过原语访问服务<ul>
<li>面向连接<ul>
<li>电话系统: 面向连接, 先建立连接再传输信息</li>
<li>邮局系统: 无连接, 报文由中间节点路由, 前后独立</li>
</ul>
</li>
<li>可靠服务<ul>
<li>可靠: 从不丢失数据, 一般会向发送方确认接收</li>
<li>不可靠: 不反馈, 不保证不丢失</li>
<li>面向连接的服务不一定可靠, 字节流, 数字化语音</li>
</ul>
</li>
</ul>
</li>
<li>接口: 定义上层访问下层的参数以及结果</li>
<li>协议: 双方之间如何进行通信的约定</li>
<li>服务与协议的关系</li>
</ul>
<h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><ul>
<li>OSI: 多一个物理, 会话, 表示层</li>
<li>TCP/IP: 数据链路层, 网络层, 传输层, 应用层</li>
<li>比较<ul>
<li>相同: 建立在协议栈, 协议独立, 各层功能类似</li>
<li>区别: osi 区分了协议服务接口, 通用, 在协议之前产生, 网络层支持面向连接与无连接, 传输层只支持面向连接tcp/ip 没有区分, 只适用于 tcp/ip, 现有协议, 网络层只支持无连接, 传输层两种都支持</li>
</ul>
</li>
</ul>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><ul>
<li>数据通信<ul>
<li>概念<ul>
<li>带宽: 传输中不会明显减弱频率的宽度, 取决于介质</li>
<li>信噪比: 信号功率 S 与噪声功率 N 比值</li>
<li>分贝: 用对数表示信噪比 $10\lg(\frac{S}{N})$</li>
</ul>
</li>
<li>计算信道最大传输速率 (比特/秒)<ul>
<li>香浓定理: 带宽为 B hz, 信噪比为 S/N 的有噪声信道的最大数据传输率 $B\log_2{1+\frac{S}{N}}$</li>
<li>尼奎斯特: 有限带宽的无噪声信道的最大数据传输率, V 是离散级别 $2B\log_2{V}$</li>
</ul>
</li>
</ul>
</li>
<li>传输介质<ul>
<li>双绞线: 噪音不干扰电压差<ul>
<li>全双工, 半双工, 单工</li>
</ul>
</li>
<li>同轴电缆: 高带宽, 高抗噪</li>
</ul>
</li>
<li>公共电话交换网<ul>
<li>数字调制: 模拟信号表示比特, 比特与信号之间转换的过程</li>
<li>基带传输: 传输占用从零到最大频率, 有线</li>
<li>通带传输: 信号占据以载波信号频率为中心的一段频率, 无线和光纤</li>
<li>调制解调器: 数字比特流和模拟信号流之间转换的设备</li>
<li>ADSL: 非对称数字用户线, 上下行带宽不同</li>
<li>多路复用<ul>
<li>时分, 频分, 波分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><ul>
<li>提供给网络层的服务: 提供相邻两个节点间可靠的传输</li>
<li>数据帧: 从网络层获取的数据包封装为帧<ul>
<li>格式: 帧头+数据包+帧尾<ul>
<li>ack, kind, seq, data, checksum</li>
<li>边界问题: 比特填充的标志比特法</li>
<li>透明传输: 使用转义</li>
</ul>
</li>
<li>差错控制: 保证所有帧按顺序传到目标机器的网络层</li>
<li>流量控制: 基于反馈</li>
</ul>
</li>
<li>⚡差错检测<ul>
<li>纠错码: 推断出发送的数据, 适用于错误发生频繁的信道<ul>
<li>海明码</li>
</ul>
</li>
<li>检错码: 推断是否发生错误<ul>
<li>CRC</li>
</ul>
</li>
</ul>
</li>
<li>数据链路协议<ul>
<li>滑动窗口协议: 双方维持一个<ul>
<li>发送窗口: 发送方维持一组序号, 对应允许他发送的帧</li>
<li>接收窗口: 接收方维持一个窗口对应一组允许它接受的帧</li>
<li>确认<ul>
<li>捎带确认</li>
<li>期望确认</li>
<li>累计确认</li>
</ul>
</li>
</ul>
</li>
<li>回退N</li>
<li>选择重传, 否定确认</li>
</ul>
</li>
</ul>
<p>⛩😇🌸💪✨✨✨</p>
<h2 id="第四章-介质访问控制子层-mac-层"><a href="#第四章-介质访问控制子层-mac-层" class="headerlink" title="第四章 介质访问控制子层 mac 层"></a>第四章 介质访问控制子层 mac 层</h2><ul>
<li>有线局域网<ul>
<li>csma/cd: 载波检测多路访问, 带冲突检测, 限定帧的长度</li>
</ul>
</li>
<li>无限局域网</li>
<li>交换机: 将多个lan口连接, 根据 mac 地址确认转发, 使用泛洪算法填充转发表<ul>
<li>中继器, 集线器, 交换机, 路由器, 网关</li>
</ul>
</li>
</ul>
<h2 id="第五章-网络层"><a href="#第五章-网络层" class="headerlink" title="第五章 网络层"></a>第五章 网络层</h2><ul>
<li>路由算法<ul>
<li>最优化原则: 汇集树</li>
<li>泛洪算法</li>
<li>距离矢量路由 DV, RIP</li>
<li>链路状态, OSPF</li>
</ul>
</li>
<li>拥塞控制: 网络中存在过多数据包导致数据包延迟和丢失, 降低了传输性能, 此时让路由器丢弃过多的数据包</li>
<li>IPV4<ul>
<li>IP 头: 至少20字节<ul>
<li>版本</li>
<li>ip头长</li>
<li>服务类型</li>
<li>总长度</li>
<li>ttl</li>
<li>协议</li>
<li>头检验和</li>
<li>源地址和目标地址</li>
<li>可选内容</li>
</ul>
</li>
<li>分类寻址: A,B,C,D,E 类地址, 每类网络数量固定, 主机数量相同</li>
<li>子网与前缀<ul>
<li>子网划分: 通过子网掩码将网络划分, 外部看来仍是单个网络</li>
<li>前缀: 网络号</li>
</ul>
</li>
<li>无类域间路由</li>
<li>NAT 网络地址转换</li>
<li>隧道技术</li>
</ul>
</li>
<li>Internet 控制协议<ul>
<li>ICMP: ping, 控制消息协议</li>
<li>ARP: 地址解析协议</li>
</ul>
</li>
</ul>
<h2 id="第六章-传输层"><a href="#第六章-传输层" class="headerlink" title="第六章 传输层"></a>第六章 传输层</h2><ul>
<li>建立连接: CR,ACK,DATA</li>
<li>断开连接</li>
<li>UDP: 只有把八字节头部</li>
<li>TCP<ul>
<li>TCP数据段的头<ul>
<li>源端口, 目标端口</li>
<li>序列号, seq</li>
<li>确认号, ack</li>
<li>tcp 头长, 确认字段是否有效, 建立连接 SYN, 终止 FIN, 窗口大小</li>
<li>校验和</li>
</ul>
</li>
<li>连接建立与断开<ul>
<li>建立: 三次握手</li>
<li>断开: 四次挥手</li>
</ul>
</li>
<li>拥塞控制与慢启动算法: 成倍增加拥塞窗口, 到达阈值后线性增加, 超时发生后, 将阈值降低一半, 拥塞窗口回归初始值, 拥塞窗口一直增长, 直至发生超时或到达接收窗口</li>
</ul>
</li>
</ul>
<h2 id="第七章-应用层"><a href="#第七章-应用层" class="headerlink" title="第七章 应用层"></a>第七章 应用层</h2><ul>
<li>DNS: 将域名映射为 ip</li>
</ul>
<p>传输层——数据段（Segment）<br>网络层——分组（数据包）（Packet）<br>数据链路层——数据帧（Frame）<br>物理层——比特 Bit</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>广播: 将数据发送给所有目标机器</li>
<li>协议: 双方如何进行通信的一种约定</li>
<li>汇集树: 从所有源到指定目标的最短路径的集合组成的以目标节点为根的树</li>
<li>带宽: 最大传输时频率不会明显减弱的频带宽度</li>
<li>多路复用: 多个信号可以共享同一传输路线</li>
<li>TTL: 限制数据生存周期的计数器, 单位为跳数</li>
<li>ADSL: 非对称数字用户线路</li>
<li>隧道技术: 在两个不同网络传递数据</li>
<li>ICMP: Internet 控制消息协议</li>
</ul>
<h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><ul>
<li>CRC: 循环冗余校验码<ul>
<li>生成多项式, 10011, 对帧附上长度减一的0, 帧+0000</li>
<li>加0后的帧对生成多项式模2除, 得商和余数</li>
<li>加0后的帧与余数合并, 在接收方被生成多项式整除, 则传递中无误</li>
<li>模2除法<ul>
<li>如果首位为0商0, 否则1</li>
<li>从第二位开始进行异或, 若未到最后一位余数加被除数此位置上的值, 继续直到除完</li>
</ul>
</li>
</ul>
</li>
<li>Nquist 定理<ul>
<li>带宽是 B Hz, 离散级别为 V, 可求得最大数据发送率为 $2Blog_2{V}$</li>
</ul>
</li>
<li>滑动窗口协议 GBN<ul>
<li>从出错处开始发</li>
</ul>
</li>
<li>路由计算<ul>
<li>距离矢量路由</li>
</ul>
</li>
<li>ip 地址, 140.120.84.24/20<ul>
<li>最小最大主机地址: 将原地址的后12个分别换成0和1, 得到主机地址和最大地址, 再将主机地址加一就得到了最小主机地址</li>
<li>地址掩码: 255.255.240.0, 有20个1和12个0</li>
<li>有多少主机地址</li>
</ul>
</li>
</ul>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul>
<li>滑动窗口协议<ul>
<li>1位: 发送与接收窗口大小都是1, 发送一个数据包后必须要等待其ACK才能继续发, 适用于网络差, 带宽较低的情况</li>
<li>发送窗口: 已经发送, 没有收到确认的帧的集合</li>
<li>接收窗口: 可以接受的帧的集合</li>
<li>滑动窗口如何进行流量控制: 当发送窗口满了就停止发送, 接收方可以通过减少确认来控制发送方的速率</li>
</ul>
</li>
<li>网桥(交换机)工作原理<ul>
<li>从某个端口收到报文, 解析源mac和目标mac</li>
<li>根据源mac学习形成mac表</li>
<li>根据目标mac原封不动转发到适当的出端口, 保证目标设备能收到这个报文</li>
</ul>
</li>
<li>dns 原理: 将域名或电子邮箱发送给dns服务器, 服务器返回IP地址, 这个过程使用的都是udp</li>
<li>red, 慢启动和为什么这两个可以有效解决拥塞问题<ul>
<li>red, 网络层, 当链路平均队列长度超过阈值, 该链路认为堵塞, 路由器随机丢弃小部分数据包</li>
<li>慢启动, TCP, 一开始成倍增加拥塞窗口的大小, 到达阈值后线性增加, 遇见超时情况后阈值除2, 拥塞窗口重置, 拥塞窗口一直增长直到遇见超时或达到接收方允许的窗口大小</li>
<li>如何合作: 当路由器缓冲区达到阈值, 路由器执行red, 丢弃数据包, 发送方超时然后慢启动, 降低了发送方速率</li>
</ul>
</li>
<li>漏桶令牌桶工作原理<ul>
<li>流量整形: 调节进入网络的数据的平均速率和突发性所采取的技术</li>
<li>漏桶: 无论注入桶中的速率如何, 出去的速率不变</li>
<li>令牌桶: 匀速产生令牌, 桶满了将不再增加, 出去数据需要消耗令牌, 令牌不够数据将会缓存或者丢弃, 能处理突发情况</li>
</ul>
</li>
<li>链路状态路由<ul>
<li>工作原理: 路由器通过泛洪传自身所连接的设备的地址和延迟最终构成一整张拓扑网, 然后进行最短路径生成找到路由方向</li>
<li>如何保证转发代价低, 可靠性高的信息扩散: 接受方发送反馈信息保证可靠, 引入计时器防止丢失某一帧导致发送方持续等待, 通过序号保证每一帧顺序和防止重复接受</li>
</ul>
</li>
</ul>
<h2 id="分析题"><a href="#分析题" class="headerlink" title="分析题"></a>分析题</h2><ul>
<li>介质控制访问: 解决介质中同一频率传输会互相影响, 无法获得有效信号<ul>
<li>以太网的协议是 CSMA/CD, 工作原理是发送信号前监听信道, 如果有信号则不发送, 发送时也监听, 如果线路上的信号与自己发送的不一致, 说明有冲突, 停止, 为了确保接收信号的机器知道有冲突, 需要保证信号发送的长度足够信号在两边跑一个来回, 也就是64字节的长度</li>
<li>无线网的协议 CSMA/CA</li>
</ul>
</li>
<li>路由<ul>
<li>ip 包与路由表匹配如果有多个匹配结果怎么办: 使用子网掩码长度最长的那个</li>
</ul>
</li>
<li>arp<ul>
<li>目的: 根据ip, 解析mac地址</li>
<li>工作原理: 通过arp广播, 获得相应ip地址的机器回应的mac, 然后传给交换机, 交换机根据mac传给相应的机器</li>
</ul>
</li>
</ul>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><ul>
<li>TCP/IP<ul>
<li>第一行是 IP 报头, 第二行是 TCP 头, 每个 ip 头第四个 4 字节是源ip地址, 第五个是目标</li>
<li>由 SYN 和 ACK 是否为0来判断TCP连接建立的过程, SYN,ACK是TCP头第四个4字节的11bit和14bit</li>
<li>数据链路层以太网帧长度为46到1500, 所以不足需要填充, 超过需要分开, 数据报总长度是ip头第一个4字节的第二三个,最大长度 $2^{16}$ 字节</li>
<li>TTL可以判断经过的路由器数量, ip头第三个4字节的第一个字节</li>
</ul>
</li>
<li>TCP, 填序列号和确认号, 释放后双方能否相互传输数据</li>
</ul>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/12/20/interview/">面试准备</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-20
          </time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/总结/">总结</a></span>
          <div class="content"></div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/12/19/dip/">数字图像处理</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-19
          </time>
          <div class="content"><h3 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h3><ul>
<li>数字图像<ul>
<li>由有限的离散元素组成 $f(x,y)$</li>
<li>每个元素称为像素</li>
</ul>
</li>
<li>图像在内存中的存储<ul>
<li>大小: 分辨率, 宽 x 高</li>
<li>颜色空间: rgb, cmyk</li>
<li>通道: 1, 2, 3, 4, gray &amp; color</li>
<li>深度: 每个通道的位数<ul>
<li>cv_8uc1: 8 位无符号整型单通道矩阵</li>
<li>cv_32fc2: 32 位浮点型双通道矩阵</li>
</ul>
</li>
<li>坐标系: 左手, 右手</li>
<li>交叉存储, 顺序存储</li>
</ul>
</li>
<li>邻域: 周围的像素<ul>
<li>四邻域</li>
<li>八邻域</li>
</ul>
</li>
</ul>
<h3 id="图像采样与量化"><a href="#图像采样与量化" class="headerlink" title="图像采样与量化"></a>图像采样与量化</h3><p>灰度级: $2^k$<br>dpi: 每英寸内点数</p>
<ul>
<li>采样: 数字化坐标<ul>
<li>决定图像的分辨率</li>
<li>决定图像的细节</li>
</ul>
</li>
<li>量化: 数字化幅值<ul>
<li>决定强度层数</li>
<li>决定图像的对比光滑程度, 避免锯齿</li>
</ul>
</li>
</ul>
<h3 id="几何操作"><a href="#几何操作" class="headerlink" title="几何操作"></a>几何操作</h3><ul>
<li><p>空间变换: 𝑔(𝑥,𝑦)=𝑓(𝑥′,𝑦′)=𝑓[𝑎(𝑥,𝑦),𝑏(𝑥,𝑦)]</p>
</li>
<li><p>灰度级插值</p>
<ul>
<li>重采样<ul>
<li>最近邻</li>
<li>双线性</li>
<li>三次立方</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于空域的灰度图像增强方法"><a href="#基于空域的灰度图像增强方法" class="headerlink" title="基于空域的灰度图像增强方法"></a>基于空域的灰度图像增强方法</h3><p>r: 输入像素, s: 输出像素, T:转换函数, L: 最大灰度值</p>
<ul>
<li>灰度变换<ul>
<li>线性: 255 - r, 用于反色</li>
<li>对数: 将范围较窄的低灰度值映射到较宽的灰度空间, 范围较宽的映射到较窄的灰度空间, 或者在傅里叶变换中压缩动态范围, 显示频谱细节</li>
<li>指数: 增加对比度, 对图像进行亮度修正</li>
</ul>
</li>
<li>直方图处理<ul>
<li>⚡直方图均衡化, $r_k$ 是像素灰度值, $n_k$ 是灰度值数量<ul>
<li>计算直方图 $p(r_k)=\frac{n_k}{MN}$</li>
<li>计算变换函数, 得出均衡后的直方图 $$s_k=T(r_k)=\frac{(L-1)}{MN}\sum_{j=0}^kn_j,\quad k=0,1,2,···,L-1$$</li>
<li>将点四舍五入</li>
</ul>
</li>
<li>直方图匹配(规定化)</li>
<li>图像增强中使用直方图统计</li>
</ul>
</li>
<li>空间域滤波器<ul>
<li>线性滤波器<ul>
<li>均值, 最大值</li>
</ul>
</li>
<li>行列分离高斯滤波</li>
<li>导数滤波<ul>
<li>一阶微分 - 梯度</li>
<li>二阶微分 - 拉普拉斯</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/wangguchangqing/p/6983680.html" target="_blank" rel="noopener">图像处理基础(7)：图像的灰度变换</a></p>
</blockquote>
<h3 id="频率图像增强"><a href="#频率图像增强" class="headerlink" title="频率图像增强"></a>频率图像增强</h3><ul>
<li>傅里叶变换: 时间域转为频率域</li>
<li>基本记号</li>
<li>低通滤波</li>
<li>高通滤波</li>
</ul>
<h3 id="图像修复"><a href="#图像修复" class="headerlink" title="图像修复"></a>图像修复</h3><ul>
<li>图像恢复<ul>
<li>只存在噪音的空间域图像恢复</li>
</ul>
</li>
<li>自适应中值滤波<ul>
<li>如果中值大于最小值, 小于最大值, 进行滤波</li>
<li>为否则扩大滤波器, 直至最大然后输出原像素点</li>
<li>滤波过程<ul>
<li>如果原像素点大于最小值, 小于最大值, 输出原像素点, 否则输出中值</li>
</ul>
</li>
</ul>
</li>
<li>逆向滤波</li>
</ul>
<h3 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h3><ul>
<li>膨胀: $\oplus $<ul>
<li>桥接文字裂缝</li>
</ul>
</li>
<li>腐蚀<ul>
<li>消除图像细节部分</li>
</ul>
</li>
<li>主要应用<ul>
<li>开操作: 先腐蚀再膨胀</li>
<li>闭操作: 相反</li>
<li>边界提取: 先 b 对 a 腐蚀, a 减去腐蚀后的部分</li>
<li>区域填充: b 对 a 膨胀, 直到不再增加, 且限制在一定范围内以防填充满整个区域</li>
</ul>
</li>
</ul>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/12/18/软件工程/">软件工程</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-18
          </time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/学科/">学科</a></span>
          <div class="content"><h1 id="2019-下山东大学软件工程复习"><a href="#2019-下山东大学软件工程复习" class="headerlink" title="2019 下山东大学软件工程复习"></a>2019 下山东大学软件工程复习</h1><h2 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h2><h3 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h3><ul>
<li>定义: 采用工具、技术等用来解决现实问题的综合过程</li>
<li>目的</li>
<li>方法: 面向对象, 结构化, 面向过程等模式</li>
<li>作用: 付出较低的开发成本, 达到要求的软件功能, 能按时完成, 及时交付</li>
</ul>
<h3 id="错误-缺陷-失败的含义与联系-举例"><a href="#错误-缺陷-失败的含义与联系-举例" class="headerlink" title="错误, 缺陷, 失败的含义与联系 (举例)"></a>错误, 缺陷, 失败的含义与联系 (举例)</h3><ul>
<li>错误: 开发中人为的错误, 例如需求说明, 代码中的错误</li>
<li>缺陷: 缺陷是程序功能中出现的问题</li>
<li>失败: 软件运行时出现的故障</li>
<li>联系: 软件开发时人为的错误导致了软件的缺陷, 一个错误可能导致若干个缺陷，但缺陷不一定导致失败</li>
</ul>
<h3 id="软件质量应该如何来衡量"><a href="#软件质量应该如何来衡量" class="headerlink" title="软件质量应该如何来衡量"></a>软件质量应该如何来衡量</h3><ul>
<li>产品的质量</li>
<li>生产过程中的质量</li>
<li>使用时的商业背景的质量</li>
</ul>
<h3 id="现代软件工程的几个阶段及各个阶段文档-写在方括号中"><a href="#现代软件工程的几个阶段及各个阶段文档-写在方括号中" class="headerlink" title="现代软件工程的几个阶段及各个阶段文档 (写在方括号中)"></a>现代软件工程的几个阶段及各个阶段文档 (写在方括号中)</h3><ul>
<li>需求分析: 包括问题定义, 可行性研究, 需求分析 [SRS(软件需求规格书)]</li>
<li>系统设计: 包括用户界面设计 [SAD(软件系统结构图)]</li>
<li>程序设计: 包括模块功能算法与数据描述设计 [相关文档]</li>
<li>程序实现: 包括编程与 debug [源代码和注释]</li>
<li>单元测试: 模块功能和性能测试 [测试报告]</li>
<li>集成测试: 按照结构图测试 [测试报告]</li>
<li>系统测试: 按 SRS 对系统总体功能进行测试与复审</li>
<li>系统提交: 交付产品 [用户手册和操作手册]</li>
<li>系统维修: 修改软件的过程, 为改错或满足新需求 [维修报告]</li>
</ul>
<h3 id="什么是重用-抽象等现代软件工程主要概念-软件工程的Wasserman-规范"><a href="#什么是重用-抽象等现代软件工程主要概念-软件工程的Wasserman-规范" class="headerlink" title="什么是重用, 抽象等现代软件工程主要概念 (软件工程的Wasserman 规范)"></a>什么是重用, 抽象等现代软件工程主要概念 (软件工程的Wasserman 规范)</h3><ul>
<li>重用: 重复采用以前开发的软件系统中共性的部件, 用到新的开发项目中</li>
<li>抽象: 基于某种层次归纳水平的问题描述, 使我们将注意力集中在问题的关键地方而非细节</li>
<li>分析设计方法和符号描述系统: 使用标准表示对程序进行描述, 利于交流建模并检查其完整和一致性, 利于对需求和部件践行重用</li>
<li>用户界面原型化: 建立小型的系统, 具有有限的关键功能, 以利于用户评价选择, 证明设计的可行性</li>
<li>软件体系结构: 定义一组体系结构单元及其关系集来描述软件功能, <strong>单元分解方法</strong></li>
<li>软件过程: 软件开发活动中的各种组织及规范方法</li>
<li>测量: 通用的评价方法与体系</li>
<li>工具和集成环境: 通过框架比较软件工程环境提供的服务, 以决定其好坏</li>
</ul>
<h2 id="第二章-过程和生命周期的建模"><a href="#第二章-过程和生命周期的建模" class="headerlink" title="第二章 过程和生命周期的建模"></a>第二章 过程和生命周期的建模</h2><h3 id="什么是软件过程-其重要性是什么-包含几个阶段-软件生命周期"><a href="#什么是软件过程-其重要性是什么-包含几个阶段-软件生命周期" class="headerlink" title="什么是软件过程, 其重要性是什么, 包含几个阶段, 软件生命周期"></a>什么是软件过程, 其重要性是什么, 包含几个阶段, 软件生命周期</h3><ul>
<li>定义: 一组有序的任务, 涉及活动, 约束和资源使用的一系列步骤, 用于产生某种想要的输出</li>
<li>重要性:<ul>
<li>强制活动具有一致性和一定的结构</li>
<li>过程结构允许我们分析理解控制和改进组成过程的活动, 并以此指导我们的活动</li>
<li>使我们获得经验并传授给他人</li>
</ul>
</li>
<li>生命周期: 软件开发过程描述了从概念到实现, 交付, 使用和维护等过程, 因此可以将软件开发过程称为生命周期</li>
</ul>
<h3 id="瀑布模型和各阶段文档和优缺点"><a href="#瀑布模型和各阶段文档和优缺点" class="headerlink" title="瀑布模型和各阶段文档和优缺点"></a>瀑布模型和各阶段文档和优缺点</h3><ul>
<li>定义: 线性的安排每个阶段, 将开发阶段描述为从一个阶段瀑布的转向另一个阶段, 前一个阶段必须在后一个阶段前完成</li>
<li>各阶段文档<br><img src="/image/se-1.png" alt></li>
<li>优点<ul>
<li>简单性, 易向不熟悉软件开发的客户解释</li>
<li>便于评估, 每个过程活动都有与之相关的里程碑和可交付产品</li>
<li>是很多其他模型的基础</li>
</ul>
</li>
<li>缺点<ul>
<li>无法处理重复开发的问题, 因为软件开发是一个创造的过程而非制造, 开发时大量迭代</li>
<li>文档转换有困难</li>
</ul>
</li>
</ul>
<h3 id="原型的概念与用途"><a href="#原型的概念与用途" class="headerlink" title="原型的概念与用途"></a>原型的概念与用途</h3><ul>
<li>概念: 一种部分开发的产品</li>
<li>用途: 用来让用户和开发者共同研究, 为最终产品定型</li>
</ul>
<h3 id="论述分阶段开发模型的含义-其基本分类及特点是什么"><a href="#论述分阶段开发模型的含义-其基本分类及特点是什么" class="headerlink" title="论述分阶段开发模型的含义, 其基本分类及特点是什么"></a>论述分阶段开发模型的含义, 其基本分类及特点是什么</h3><ul>
<li>系统设计成部分提交, 用户每次只能获取部分功能, 其他部分在开发中</li>
<li>基本分类和特点<ul>
<li>产品系统和开发系统</li>
<li>增量开发和迭代开发</li>
<li>增量与迭代结合</li>
<li>进化式迭代开发</li>
</ul>
</li>
</ul>
<h3 id="螺旋模型四个象限的任务及四重循环的含义"><a href="#螺旋模型四个象限的任务及四重循环的含义" class="headerlink" title="螺旋模型四个象限的任务及四重循环的含义"></a>螺旋模型四个象限的任务及四重循环的含义</h3><ul>
<li>指定计划: 确认软件目标, 选定方案, 弄清限制条件</li>
<li>风险分析: 分析所选方案, 考虑如何避免</li>
<li>实施工程: 软件开发与验证</li>
<li>客户评估: 评估开发工作, 确认下一步计划</li>
<li>四重循环: 螺旋模型共有四次迭代, 操作概念, 软件需求, 软件设计, 开发与测试, 每一次迭代根据需求和约束进行风险分析, 并通过原型化验证可行性和期望度</li>
</ul>
<h3 id="什么是UP，-RUP，进化式迭代等市场流行的过程模型"><a href="#什么是UP，-RUP，进化式迭代等市场流行的过程模型" class="headerlink" title="什么是UP， RUP，进化式迭代等市场流行的过程模型"></a>什么是UP， RUP，进化式迭代等市场流行的过程模型</h3><blockquote>
<p>参考 <a href="https://www.cnblogs.com/wj033/p/5942304.html" target="_blank" rel="noopener">软件开发学习笔记 &lt;二&gt;软件开发模型、Up、Rup、敏捷Up</a></p>
</blockquote>
<ul>
<li>up: 统一过程, 一种现代的软件开发模型, 基于构件, 系统是由构件通过接口相互链接而成, 使用 UML 来指定系统的所有蓝图</li>
<li>RUP: 统一软件开发过程, 兼容 UP, 提供开发组织中分派任务和责任的纪录化方法, 目标是在可预见的日程和预算下, 确保满足用户</li>
<li>进化式迭代: 是统一开发过程的关键实践, 开发被组织为一系列固定的短期项目, 每次迭代都产生经过测试集成并可执行的局部系统, 每次迭代都有各自的需求分析, 设计, 实现和测试, 随着迭代系统增量式完善</li>
</ul>
<h2 id="第三章-计划和管理项目"><a href="#第三章-计划和管理项目" class="headerlink" title="第三章 计划和管理项目"></a>第三章 计划和管理项目</h2><h3 id="什么是项目进度-活动-里程碑"><a href="#什么是项目进度-活动-里程碑" class="headerlink" title="什么是项目进度, 活动, 里程碑"></a>什么是项目进度, 活动, 里程碑</h3><ul>
<li>项目进度: 对特定项目的软件开发周期的刻画, 包括对项目阶段, 步骤, 活动的分离和各个活动的完成时间以及整个项目的完成时间的估算</li>
<li>活动: 项目的一部分, 占用项目计划中的一段时间</li>
<li>里程碑: 指特定的时间点, 标志着活动的结束, 伴随着提取物 (如一般性文档，功能模块的说明，子系统的说明和展示，精确度的说明和展示，可靠性，安全性，性能说明或展示文档)</li>
</ul>
<h3 id="⚡-如何计算软件项目活动图的关键路径-冗余时间-最早和最迟开始时间"><a href="#⚡-如何计算软件项目活动图的关键路径-冗余时间-最早和最迟开始时间" class="headerlink" title="⚡ 如何计算软件项目活动图的关键路径, 冗余时间, 最早和最迟开始时间"></a>⚡ 如何计算软件项目活动图的关键路径, 冗余时间, 最早和最迟开始时间</h3><blockquote>
<p>(习题2，3)</p>
</blockquote>
<p><img src="/image/se-3.png" alt><br>上图描述了活动和活动间依赖关系的图, 其中节点表示项目的里程碑 (活动结束), 线是活动, A-&gt;B 不是从活动 A 到 B, 意思是有个活动完成后到 B 里程碑</p>
<ul>
<li>估算项目完成时间<ul>
<li>关键路径: 从起点到终点花费最长时间的路径, 即这个项目的最短完成时间, 若它没完成, 整个项目不能算完成</li>
<li>冗余时间: 在不耽误整体项目时间的最晚时间减去最早时间</li>
<li>最早最晚开始时间计算: 首先关键路径时间是不能耽误的, 没有冗余时间, 表示方式为 &lt;最早,最晚,冗余&gt;, <strong>最晚时间</strong>, 从后往前, 在关键路径的里程碑上的最晚时间, 减去其他分支的活动时间就是这个分支的最晚时间 (因为关键路径上一刻不停, 完成时整个项目就完成了), 若有多个分支选择最小的最晚时间, 以防耽误项目, <strong>最早时间</strong>, 按照关键路径的方法算每个到达里程碑的路径, 由于只有两个活动都到了里程碑才能开始下一个里程碑, 所以在多个分支处选择最晚的作为此里程碑的最早时间</li>
</ul>
</li>
</ul>
<h3 id="软件项目团队组织的基本结构"><a href="#软件项目团队组织的基本结构" class="headerlink" title="软件项目团队组织的基本结构"></a>软件项目团队组织的基本结构</h3><ul>
<li>主程序负责制: 由一个主程负责系统设计和开发, 其他成员向其汇报, 对每一个决定有绝对决策权</li>
<li>忘我方法: 每一个成员平等承担责任, 过程和个人分开, 批评针对产品和结果而非个人</li>
</ul>
<h3 id="试述COCOMO模型的三个阶段基本工作原理或含义"><a href="#试述COCOMO模型的三个阶段基本工作原理或含义" class="headerlink" title="试述COCOMO模型的三个阶段基本工作原理或含义"></a>试述COCOMO模型的三个阶段基本工作原理或含义</h3><ul>
<li>定义: cocomo 针对项目开发的不同阶段设置工作量的衡量标准, 逐步细化准确</li>
<li>阶段一: 构建原型解决高风险问题, 此时 ccm 用应用点来估计规模</li>
<li>二: 早期设计阶段, 使用功能点对规模进行测量</li>
<li>三: 后体系结构阶段, 开发已经开始, 可以根据功能点和代码行进行规模估计</li>
</ul>
<h3 id="什么是软件风险-了解主要风险管理活动-有几种降低风险的策略"><a href="#什么是软件风险-了解主要风险管理活动-有几种降低风险的策略" class="headerlink" title="什么是软件风险, 了解主要风险管理活动, 有几种降低风险的策略"></a>什么是软件风险, 了解主要风险管理活动, 有几种降低风险的策略</h3><ul>
<li>定义: 开发中不希望看见的, 有负面结果的事件</li>
<li>主要风险管理活动<ul>
<li>风险评价: 风险识别</li>
<li>风险控制: 风险降低</li>
</ul>
</li>
<li>降低风险的策略<ul>
<li>避免: 改变功能和性能需求, 是风险没机会发生, 如为防止内存泄漏从 c 到 java</li>
<li>转移: 把风险转移到其他系统, 如购买保险</li>
<li>假设: 接受并控制风险, 比如开发时有意识进行测试</li>
</ul>
</li>
</ul>
<h3 id="⚡弄懂活动图基本原理-参考课本-找出课后练习题图3-23和3-24的关键路径"><a href="#⚡弄懂活动图基本原理-参考课本-找出课后练习题图3-23和3-24的关键路径" class="headerlink" title="⚡弄懂活动图基本原理(参考课本), 找出课后练习题图3.23和3.24的关键路径"></a>⚡弄懂活动图基本原理(参考课本), 找出课后练习题图3.23和3.24的关键路径</h3><ul>
<li>定义: 活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。</li>
</ul>
<h2 id="第四章-获取需求"><a href="#第四章-获取需求" class="headerlink" title="第四章 获取需求"></a>第四章 获取需求</h2><h3 id="需求的含义是什么"><a href="#需求的含义是什么" class="headerlink" title="需求的含义是什么"></a>需求的含义是什么</h3><p>定义: 对来自用户的软件期望的综合描述, 设计软件的对象, 状态, 约束, 功能</p>
<h3 id="需求阶段作为一个工程，其确定需求的过程是什么"><a href="#需求阶段作为一个工程，其确定需求的过程是什么" class="headerlink" title="需求阶段作为一个工程，其确定需求的过程是什么"></a>需求阶段作为一个工程，其确定需求的过程是什么</h3><ul>
<li>原始需求获取: 客户给出的需求</li>
<li>问题分析: 理解需求并建模描述</li>
<li>规格说明草稿: 利用符号描述系统将需求规范化</li>
<li>需求核准: 开发人员与客户进行核准</li>
<li>SRS, 软件规格说明</li>
</ul>
<h3 id="举例说明获取需求时-若有冲突发生时-如何考虑根据优先级进行需求分类"><a href="#举例说明获取需求时-若有冲突发生时-如何考虑根据优先级进行需求分类" class="headerlink" title="举例说明获取需求时, 若有冲突发生时, 如何考虑根据优先级进行需求分类"></a>举例说明获取需求时, 若有冲突发生时, 如何考虑根据优先级进行需求分类</h3><ul>
<li>必须完成的需求</li>
<li>非常值得做但并非必须</li>
<li>可选的</li>
</ul>
<h3 id="需求文档分为哪两类"><a href="#需求文档分为哪两类" class="headerlink" title="需求文档分为哪两类"></a>需求文档分为哪两类</h3><ul>
<li>需求定义: 完整罗列客户的需求期望</li>
<li>需求规格描述: 将需求重述为要构建的系统将如何运转的规格说明</li>
</ul>
<h3 id="什么是功能性需求和非功能性需求-质量需求-设计约束-过程约束-如何区分"><a href="#什么是功能性需求和非功能性需求-质量需求-设计约束-过程约束-如何区分" class="headerlink" title="什么是功能性需求和非功能性需求/质量需求, 设计约束, 过程约束, 如何区分"></a>什么是功能性需求和非功能性需求/质量需求, 设计约束, 过程约束, 如何区分</h3><ul>
<li>功能性需求: 描述系统内部功能和外部功能的交互作用, 涉及系统输入应对, 实体状态变化, 输出结果, 设计约束, 过程约束</li>
<li>质量需求: 描述软件的质量特征, 保证性能, 应用性和可靠性</li>
<li>过程约束: 对用于构建系统的技术和资源的限制, 涵盖资源文档等方面</li>
<li>设计约束: 已经作出的或限制系统解决方案的设计决策, 涵盖物理环境, 接口, 用户等方面</li>
</ul>
<h3 id="⚡了解DFD-数据流-图的构成及画法"><a href="#⚡了解DFD-数据流-图的构成及画法" class="headerlink" title="⚡了解DFD(数据流)图的构成及画法"></a>⚡了解DFD(数据流)图的构成及画法</h3><ul>
<li>定义: 描述数据进入转换流出系统</li>
<li>构成与画法<br><img src="/image/se-5.png" alt></li>
</ul>
<blockquote>
<p><a href="https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%9B%BE" target="_blank" rel="noopener">数据流程图</a></p>
</blockquote>
<h2 id="第五章-设计体系结构"><a href="#第五章-设计体系结构" class="headerlink" title="第五章 设计体系结构"></a>第五章 设计体系结构</h2><h3 id="什么是软件体系结构-设计模式-设计公约-设计"><a href="#什么是软件体系结构-设计模式-设计公约-设计" class="headerlink" title="什么是软件体系结构, 设计模式, 设计公约, 设计"></a>什么是软件体系结构, 设计模式, 设计公约, 设计</h3><ul>
<li>设计体系结构: 一种软件解决方案, 如何分解为单元, 单元之间的联系和单元的所有外部特性</li>
<li>设计模式: 一种针对单个或小范围软件模块的一般性解决方案, 提供较低层次的设计决策, 它是一个共同的设计结构的关键方面</li>
<li>设计公约: 一系列设计和决策的集合, 用于提高系统某方面的设计质量, 当其发展成熟后会封装成设计模式或体系结构甚至成为内嵌程序语言结构</li>
<li>设计: 将需求中的问题描述转变为软件解决方案的创造性过程</li>
</ul>
<h3 id="软件设计过程模型的几个阶段"><a href="#软件设计过程模型的几个阶段" class="headerlink" title="软件设计过程模型的几个阶段"></a>软件设计过程模型的几个阶段</h3><ul>
<li>建模: 根据需求中系统的特性确定软件体系结构风格</li>
<li>分析: 分析初步的软件体系结构, 主要包括质量, 安全, 可靠性</li>
<li>文档化: 确定各个不同的模型视图</li>
<li>复审: 检查文档是否满足了所有的需求</li>
<li>最终输出: SAD 软件体系结构文档, 用来和其他开发人员交流系统级设计决策的工具</li>
</ul>
<h3 id="论述设计用户界面应考虑的问题"><a href="#论述设计用户界面应考虑的问题" class="headerlink" title="论述设计用户界面应考虑的问题"></a>论述设计用户界面应考虑的问题</h3><ul>
<li>要素<ul>
<li>隐喻: 可识别和学习的基本术语, 图像和概念</li>
<li>思维模型: 数据功能任务的组织和展示</li>
<li>导航规则: 怎样在数据, 功能, 活动和角色中切换</li>
<li>外观: 系统向用户传输的外观特征</li>
<li>感觉: 向用户提供有吸引力的交互</li>
</ul>
</li>
<li>文化问题</li>
<li>用户偏好</li>
</ul>
<h3 id="举例说明耦合与内聚的基本分类。以及各个分类的含义与特征"><a href="#举例说明耦合与内聚的基本分类。以及各个分类的含义与特征" class="headerlink" title="举例说明耦合与内聚的基本分类。以及各个分类的含义与特征"></a>举例说明耦合与内聚的基本分类。以及各个分类的含义与特征</h3><ul>
<li>耦合: 指两个软件之间的相互关联度<ul>
<li>根据模块间以来的多少: 紧密, 松散, 非耦合</li>
<li>内容耦合: 一个模块修改了另一个模块, 被修改的模块完全依赖于修改他的模块</li>
<li>公共耦合: 不同模块可以从公共数据区获取数据</li>
<li>控制耦合: 一个模块通过传递参数或返回语句来控制另一模块的活动</li>
<li>标记/特征耦合</li>
<li>数据耦合</li>
<li>非耦合</li>
</ul>
</li>
<li>内聚: 指模块内部成分的关联度, 如数据, 内部模块和功能<ul>
<li>偶然</li>
<li>逻辑</li>
<li>时间</li>
<li>过程</li>
<li>通讯</li>
<li>顺序</li>
<li>功能</li>
<li>信息</li>
</ul>
</li>
</ul>
<h3 id="软件过程中复审的概念-设计复审的重要性"><a href="#软件过程中复审的概念-设计复审的重要性" class="headerlink" title="软件过程中复审的概念, 设计复审的重要性"></a>软件过程中复审的概念, 设计复审的重要性</h3><ul>
<li>定义: 检查文档是否满足所有功能和质量需求, 通过验证和确认</li>
<li>重要性<ul>
<li>复审时的批评讨论是忘我的, 能增加开发之间的交流</li>
<li>此时发现问题的成本不高, 找到故障能让每个人受益</li>
</ul>
</li>
</ul>
<h2 id="第六章-考虑对象"><a href="#第六章-考虑对象" class="headerlink" title="第六章 考虑对象"></a>第六章 考虑对象</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>上面有, 软件设计过程中, 涉及到的常用问题, 以及解决这些问题的方案和核心内容</p>
<h3 id="了解OO设计的基本原则"><a href="#了解OO设计的基本原则" class="headerlink" title="了解OO设计的基本原则"></a>了解OO设计的基本原则</h3><ul>
<li>单一职责</li>
<li>重用</li>
<li>开闭</li>
<li>替换</li>
<li>依赖倒置</li>
<li>接口隔离</li>
<li>迪米特法则</li>
</ul>
<h3 id="了解OO开发有何优势"><a href="#了解OO开发有何优势" class="headerlink" title="了解OO开发有何优势"></a>了解OO开发有何优势</h3><ul>
<li>语言的一致性: 使用相同的语义结构来描述解决问题</li>
<li>全开发过程的一致性: 从需求分析到设计和开发与测试用的相同的语义结构</li>
</ul>
<h3 id="OO开发过程有几个步骤"><a href="#OO开发过程有几个步骤" class="headerlink" title="OO开发过程有几个步骤"></a>OO开发过程有几个步骤</h3><ul>
<li>需求分析和设计</li>
<li>高层设计</li>
<li>底层设计</li>
<li>编码</li>
<li>设计</li>
</ul>
<h3 id="掌握用例图的组成和画法-用例的几个要素的含义"><a href="#掌握用例图的组成和画法-用例的几个要素的含义" class="headerlink" title="掌握用例图的组成和画法, 用例的几个要素的含义"></a>掌握用例图的组成和画法, 用例的几个要素的含义</h3><ul>
<li>用例图: 表示一个用户、外部系统或其他实体和在开发系统的关系<ul>
<li>用例: 描述系统提供的特定功能</li>
<li>执行者: 和系统交互的实体</li>
<li>包含: 对已定义用例的复用, 提取公共行为</li>
<li>扩展: 对用例的扩展使用, 如自动登录</li>
</ul>
</li>
</ul>
<h3 id="用例图、类图等针对面向对象的项目开发的意义是什么"><a href="#用例图、类图等针对面向对象的项目开发的意义是什么" class="headerlink" title="用例图、类图等针对面向对象的项目开发的意义是什么"></a>用例图、类图等针对面向对象的项目开发的意义是什么</h3><ul>
<li>用例图: 阐明需求, 找到问题, 便于交流</li>
<li>类图<ul>
<li>数据封装为类</li>
<li>类与类之间的关系</li>
</ul>
</li>
</ul>
<h3 id="熟悉类图中各个类之间的基本关系分类及其含义。"><a href="#熟悉类图中各个类之间的基本关系分类及其含义。" class="headerlink" title="熟悉类图中各个类之间的基本关系分类及其含义。"></a>熟悉类图中各个类之间的基本关系分类及其含义。</h3><ul>
<li>关联</li>
<li>依赖: 使用另一个类作参数</li>
<li>泛化</li>
<li>接口实现</li>
<li>继承, 关联, 聚合, 组合, 依赖, 接口实现<h3 id="熟悉用例图、类图的组成和画法"><a href="#熟悉用例图、类图的组成和画法" class="headerlink" title="熟悉用例图、类图的组成和画法"></a>熟悉用例图、类图的组成和画法</h3></li>
<li>类图<ul>
<li>类<ul>
<li>类名</li>
<li>属性</li>
<li>操作</li>
</ul>
</li>
<li>类之间的关系<ul>
<li>关联</li>
<li>依赖</li>
<li>泛化</li>
<li>接口实现<h3 id="了解UML其他图示结构的基本用途"><a href="#了解UML其他图示结构的基本用途" class="headerlink" title="了解UML其他图示结构的基本用途"></a>了解UML其他图示结构的基本用途</h3></li>
</ul>
</li>
</ul>
</li>
<li>定义: 一种符号表示方法</li>
<li>类描述模板: 描述了程序设计的基础(类的层次, 操作等)</li>
<li>包图: 展示包和类之间的依赖</li>
<li>对象图: 解释对象</li>
</ul>
<h2 id="第七章-编写程序"><a href="#第七章-编写程序" class="headerlink" title="第七章 编写程序"></a>第七章 编写程序</h2><h3 id="一般性的编程原则应该从哪三个方面考虑"><a href="#一般性的编程原则应该从哪三个方面考虑" class="headerlink" title="一般性的编程原则应该从哪三个方面考虑"></a>一般性的编程原则应该从哪三个方面考虑</h3><ul>
<li>控制结构: 当设计转换为代码, 会保留组件间的控制结构, 在隐含调用的面向对象设计中, 控制是基于系统设计和变量的</li>
<li>算法: 程序设计会在编写组建时使用一定算法</li>
<li>数据结构: 编写时应该按照数据的格式进行存储, 使数据管理操作简单易懂</li>
</ul>
<h3 id="在编写程序内部文档时-除了HCB外-还应添加什么注释信息-注意什么"><a href="#在编写程序内部文档时-除了HCB外-还应添加什么注释信息-注意什么" class="headerlink" title="在编写程序内部文档时, 除了HCB外, 还应添加什么注释信息, 注意什么"></a>在编写程序内部文档时, 除了HCB外, 还应添加什么注释信息, 注意什么</h3><ul>
<li>HCB: 头注释块, 将注释信息放在构建开始处, 包括构件名, 作者, 配置在系统的哪个部分, 何时编写修改的</li>
<li>其他程序注释<ul>
<li>程序每行都在做什么</li>
<li>将代码分解为段, 段再分步骤</li>
<li>随着时间进行修改的记录</li>
</ul>
</li>
<li>有意义的变量名和语句标记</li>
<li>注意缩进结构</li>
</ul>
<h3 id="什么是极限编程-XP-以及派对编程"><a href="#什么是极限编程-XP-以及派对编程" class="headerlink" title="什么是极限编程(XP), 以及派对编程"></a>什么是极限编程(XP), 以及派对编程</h3><ul>
<li>极限编程: 敏捷过程的一种, 提供敏捷开发的原则方针指导</li>
<li>派对/结对编程: 敏捷开发的主要方式, 两个程序员共同开发, 一个开发, 一个复审两个人经常交换角色</li>
</ul>
<h2 id="第八章-测试程序"><a href="#第八章-测试程序" class="headerlink" title="第八章 测试程序"></a>第八章 测试程序</h2><h3 id="了解-产生软件缺陷的原因"><a href="#了解-产生软件缺陷的原因" class="headerlink" title="了解 产生软件缺陷的原因"></a>了解 产生软件缺陷的原因</h3><ul>
<li>系统设计</li>
<li>不清晰的需求</li>
<li>程序实现</li>
<li>测试有误</li>
<li>不正确不清晰的设计规格说明</li>
</ul>
<h3 id="有几种主要的缺陷类型"><a href="#有几种主要的缺陷类型" class="headerlink" title="有几种主要的缺陷类型"></a>有几种主要的缺陷类型</h3><ul>
<li>算法: 由于处理步骤的错误, 构件对于给定的输入没有正确的输出</li>
<li>计算/精度: 公式是错的或者给出的数据的精度有问题</li>
<li>文档: 文档与程序不一致</li>
<li>压力/过载: 对队列长度, 缓冲区, 表的使用超过了软件的能力</li>
<li>能力/边界: 系统的使用到了极限的情况时, 性能变得无法接受</li>
</ul>
<h3 id="什么是正交缺陷分类"><a href="#什么是正交缺陷分类" class="headerlink" title="什么是正交缺陷分类"></a>什么是正交缺陷分类</h3><ul>
<li>被分类的故障只属于一类, 如果属于多个类别, 则不正交</li>
</ul>
<h3 id="测试的各个阶段及其任务"><a href="#测试的各个阶段及其任务" class="headerlink" title="测试的各个阶段及其任务"></a>测试的各个阶段及其任务</h3><ul>
<li>模块/构件/单元: 将系统中的构件隔开, 对其本身测试</li>
<li>集成: 验证系统构件能否按照规格中的描述共同工作</li>
<li>功能: 对系统集成进行测试, 验证是否按照需求规格说明描述的功能, 结果是一个可运转的系统</li>
<li>性能: 测试系统的软硬件性能是否符合规格</li>
<li>验收: 确认系统按照用户期望运行</li>
<li>安装: 确认系统在实际环境中按照应有的方式运行</li>
<li>系统: 功能,性能, 验收, 安装统称为系统测试</li>
<li>图片 fig.8.3<br><img src="/image/se-2.png" alt></li>
</ul>
<h3 id="掌握测试的方法—-黑盒、白盒的概念"><a href="#掌握测试的方法—-黑盒、白盒的概念" class="headerlink" title="掌握测试的方法—-黑盒、白盒的概念"></a>掌握测试的方法—-黑盒、白盒的概念</h3><ul>
<li>黑盒: 将测试的对象看做不知内容的盒子, 向其中输入数据期待正确的输出, 输入输出参考的是系统设计和程序设计的文档</li>
<li>白盒: 将对象看做白盒, 针对结构用不同方法测试, 可以测试每个模块细节</li>
</ul>
<h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h3><ul>
<li>针对程序模块的正确性验证的测试</li>
<li>测试是测试用例的有限集合, 语句, 分支, 路径测试</li>
</ul>
<h3 id="黑盒白盒方法各自的分类-测试用例的设计和给出方法"><a href="#黑盒白盒方法各自的分类-测试用例的设计和给出方法" class="headerlink" title="黑盒白盒方法各自的分类, 测试用例的设计和给出方法"></a>黑盒白盒方法各自的分类, 测试用例的设计和给出方法</h3><ul>
<li>黑盒<ul>
<li>等价分类: 将输入划分为若干等价类, 如果其中一个没有问题那么等价类中的都没问题, 减少测试时间</li>
<li>边界值分析: 在等价分类法的基础上, 测试值选择分类的边界效果更好</li>
<li>错误猜测: 猜测程序哪里会出错, 根据此来设计测试用例</li>
<li>因果图: 适合程序有很多输入, 输出又依赖程序的输入的情况</li>
</ul>
</li>
<li>白盒<ul>
<li>语句覆盖</li>
<li>条件覆盖: 判定中的每个分支, 真与假都测一遍</li>
<li>判定覆盖:</li>
<li>条件组合: 每个条件结果的组合都出现一遍</li>
</ul>
</li>
</ul>
<h3 id="⚡如何面对一个命题-设计和给出测试用例的问题"><a href="#⚡如何面对一个命题-设计和给出测试用例的问题" class="headerlink" title="⚡如何面对一个命题, 设计和给出测试用例的问题"></a>⚡如何面对一个命题, 设计和给出测试用例的问题</h3><ul>
<li>例如: 某城市的电话号码由3 部分组成。这3 个部分的名称与内容分别是<pre><code>地区码：空白或3 位数字；
前缀：非’0’或’1’开头的3 位数字；
后缀：4 位数字。</code></pre>  假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的号码，请使<br>  用等价类的思路设计测试用例。<br>  <img src="/image/se-4.png" alt></li>
<li>对于有效等价类可以用一个测试, 无效等价类采用单一变量的原则, 每次测试一个无效等价类</li>
</ul>
<h3 id="集成测试及其主要方法的分类-驱动-桩的概念"><a href="#集成测试及其主要方法的分类-驱动-桩的概念" class="headerlink" title="集成测试及其主要方法的分类, (驱动, 桩的概念)"></a>集成测试及其主要方法的分类, (驱动, 桩的概念)</h3><ul>
<li>自底向上: 从系统中最底层的构件开始接着测试调用了这些底层构件的构件, 反复直到所有构件测试完毕<ul>
<li>驱动: 测试底层时, 由于没有已测试的调用底层的构件, 所以需要编写特定的代码来调用底层的代码来辅助集成</li>
</ul>
</li>
<li>自顶向下: 顶层构件通常独立单独测试, 然后将被测的构件中调用的构件汇总起来, 作为一个更大的单元测试, 重复直到完毕<ul>
<li>桩: 用来充当下层模块的应答程序</li>
</ul>
</li>
</ul>
<h2 id="第九章-测试系统"><a href="#第九章-测试系统" class="headerlink" title="第九章 测试系统"></a>第九章 测试系统</h2><h3 id="系统测试的主要步骤及各自含义"><a href="#系统测试的主要步骤及各自含义" class="headerlink" title="系统测试的主要步骤及各自含义"></a>系统测试的主要步骤及各自含义</h3><ul>
<li>功能测试: 系统功能需求</li>
<li>性能测试: 其他软件需求</li>
<li>验收测试: 客户需求说明</li>
<li>安装测试: 客户环境</li>
</ul>
<h3 id="功能测试的含义极其作用和基本指导原则"><a href="#功能测试的含义极其作用和基本指导原则" class="headerlink" title="功能测试的含义极其作用和基本指导原则"></a>功能测试的含义极其作用和基本指导原则</h3><ul>
<li>定义: 测试需求设计的功能性需求</li>
<li>作用: 能检测出故障</li>
<li>基本指导原则<ul>
<li>高故障检测概率</li>
<li>使用独立的测试小组</li>
<li>了解期望的输出</li>
<li>合法不合法输入都要测试</li>
<li>制定停止测试的标准</li>
</ul>
</li>
</ul>
<h3 id="性能测试的含义与作用与主要分类"><a href="#性能测试的含义与作用与主要分类" class="headerlink" title="性能测试的含义与作用与主要分类"></a>性能测试的含义与作用与主要分类</h3><ul>
<li>定义: 针对非功能需求</li>
<li>作用: 确保系统的可用性, 可靠性, 可维护性</li>
<li>分类<ul>
<li>压力: 短时间内加满负荷验证系统能力</li>
<li>容量: 验证系统处理大量数据</li>
<li>配置: 测试各种软硬件配置</li>
<li>兼容性: 与其他系统交互时</li>
<li>回归: 如果这个系统要替代现有系统</li>
</ul>
</li>
</ul>
<h3 id="确认测试概念-确认测试分类"><a href="#确认测试概念-确认测试分类" class="headerlink" title="确认测试概念, 确认测试分类"></a>确认测试概念, 确认测试分类</h3><ul>
<li>定义: 确认系统满足了客户的需要, 确认测试的编写, 执行评估都是由客户进行, 只有请求某个技术问题才需要开发人员</li>
<li>分类<ul>
<li>基准: 客户准备用例, 在实际安装运行的系统运作并对系统运行情况进行评估</li>
<li>引导: 相对系统的日常性工作测试, 没有基准测试正式</li>
</ul>
</li>
</ul>
<h3 id="什么是alpha测试-β测试"><a href="#什么是alpha测试-β测试" class="headerlink" title="什么是alpha测试, β测试,"></a>什么是alpha测试, β测试,</h3><ul>
<li>α测试: 在向客户发布之前, 先由公司用户来测试</li>
<li>β测试: 客户的测试</li>
</ul>
<h3 id="什么是安装测试"><a href="#什么是安装测试" class="headerlink" title="什么是安装测试"></a>什么是安装测试</h3><ul>
<li>定义: 在用户的环境配置系统, 测试可能因为开发与用户环境不同导致的问题</li>
</ul>
<blockquote>
<p>往年试卷才是最重要的, 知识点都是其次, 另外软工试卷题目十几年来都没啥变化, 下面是05与07年的题目和答案<br><a href="/ref/se.rar">下载</a></p>
</blockquote>
<h2 id="软件工程模拟试卷2019年下（A）"><a href="#软件工程模拟试卷2019年下（A）" class="headerlink" title="软件工程模拟试卷2019年下（A）"></a>软件工程模拟试卷2019年下（A）</h2><p>备注1：请使用中文回答问题。<br>备注2：所有题目都要写到试卷的指定位置（例如：试卷上），以免流水阅卷时有遗漏<br>备注3：复习时以课件为主，英文中文教材为辅。</p>
<p>一. 解释下列名词的含义（每个小题2分，共 X 分）<br>1．软件工程（Software Engineering）<br>2．过程（Process）<br>3．黑盒测试（ Black-box Test）<br>二. 判断（填写 × 或 √）（每个小题1分，共 X 分）<br>1．(    ) 当软件系统的效率与可维护性产生抵触时，应强调效率。<br>2．(    ) 开发软件时可随便选择一种语言进行开发。<br>3．(    ) 抽象是面向对象的开发方法中独有的策略，在传统的开发方法中不需使用。<br>4．(    ) 桩模块的编写比驱动模块更困难。</p>
<p>三. 从供选择的答案中，选出正确的答案填入（　）内。（每个题空1分，共 X 分）</p>
<ol>
<li>下列选项不属于瀑布模型的优点的是（    ）。<br>A．可迫使开发人员采用规范的方法<br>B．严格的规定了每个阶段必须提交的文档<br>C．要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证<br>D．支持后期的变动<br>2．软件生命周期一般都被划分为若干个独立的阶段，其中占用精力和费用最多的阶段往往是（   ）。<br>A．运行和维护阶段      B. 设计阶段<br>C．代码实现阶段        D. 测试阶段</li>
<li>软件是计算机系统中与硬件相互依存的部分，它是包括（A）、（B）及（C）的完整集合。其中，（A）是按事先设计的功能和性能要求执行的指令序列，（B）是使程序能够正确操纵信息的数据结构，（C）是与程序开发、维护和使用有关的图文资料。<br>A，B，C：① 软件    ② 程序     ③ 代码     ④ 硬件<br>⑤ 文档    ⑥ 外设     ⑦ 数据     ⑧ 图表<br>填入答案（A：        B：         C：           ）<br>四．简述题（每个小题6分，共 X 分）<br>//   1．名词解释。<br>2．某个开发模型的含义及特点。<br>3．列出你所知道的模块间的各种耦合关系<br>4．说明软件测试过程的主要步骤及含义。<br>5．提出某种观点，请予以评价并说明理由。<br>五．综合应用题（共 X 分）<br>1．根据给定的文字命题，画出UML分析图以及描述。<br>2．测试方面的题目<br>（提出实际命题，要求给出测试用例）。<br>（基本概念，或单元测试，或集成测试概念等）。</li>
<li>高级语言程序设计的基本技术用以实现软件工程的某个设计概念。<br>4．OO的基本设计方法和技巧等。</li>
</ol>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/12/16/tips/">tips</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-16
          </time>
          <div class="content"><p><strong>找不到分类却又想记录下来就来这里吧</strong></p>
<ul>
<li><p>关闭外在信息与洗澡时思维活跃: 洗澡时感官封闭, 接收不到外界信息, 迫使大脑聚焦记忆中储存的想法</p>
</li>
<li><p>如果有并非是科学为攀升的手段的世界, 并且是魔法为主的话, 那么魔法应该就是那个世界的科学吧, 那么那样的世界会是怎样的世界呢, 这里面牵涉的政治, 文化, 经济等实在令人着迷</p>
</li>
<li><p>module.paths.push(‘C:/Users/xxx/AppData/Roaming/npm/node_modules’);<br>// node 全局位置</p>
</li>
</ul>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/12/16/绘画/">绘画</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-16
          </time>
          <div class="content"><p>越深入, 越有趣</p>
<p>比起直接上手临摹, 肯定是先学会规律最有效, 但是这些资料真的好难找啊 —– 找到了 =&gt; krenz 🙂, 下面这些是按照一本素描书整体来的思路, 再凑上自己零碎的想法和知乎搜索, google 搜索来的答案, 这些东西和自己实际想达成的过于不相符, 直到看到了 krenz 的绘画地图, 其实之前就搜到了, 但是 170 分钟劝退, 好在我还是看了🤣, 过于契合, 非常棒, 明年二期课去见识见识, 这之前先练习转型与透视吧</p>
<p>看出问题很容易, 一般就那么几个方向, 确诊问题很难, 因为方向里有很多细节, 解决它需要经验与练习</p>
<p>Q&amp;A:</p>
<ul>
<li><p>线条很难看</p>
<ul>
<li>速度不够快</li>
<li>多条短线拼成长线, 而非一笔, 需要多练</li>
<li>大的幅度两三笔完成, 结合撤销, 不要用橡皮擦<blockquote>
<p><a href="https://www.bilibili.com/video/av45479124/" target="_blank" rel="noopener">光看线条就知道你是啥样的人！？勾线怎么才能不手抖？【抖抖村】</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何画形准: <strong>目的是为了能下次默写出来</strong>, 形准是其次(因为只要透视比例大致对怎样都能像那么回事)</p>
<ul>
<li>网格法</li>
<li>三角形概括再取负形法</li>
</ul>
</li>
<li><p>如何练习比例</p>
<ul>
<li>画曲线, 对着画, 然后移上去对比并改至一致</li>
</ul>
</li>
</ul>
<p><strong>下面的姑且先作废</strong>, 舍不得删, 将来回顾下青春版的学习流程, 用来作例子</p>
<p><strong>当前目标</strong></p>
<ul>
<li><strong>找到学习流程</strong><ul>
<li>线条练习, 对线条的质量控制优于排线</li>
<li>如何练习起形</li>
<li>学习自动铅笔上光影</li>
<li>速写: 直接练习最感兴趣的方向, 另外素描与现有的工具并不相符, 很多肌理难以表现</li>
</ul>
</li>
</ul>
<p><strong>当前问题</strong></p>
<ul>
<li>所想学习的和目标不相似<ul>
<li>我想画的是日漫风, 但是学习的话往往都是素描开始, 离得远, 又难, 所以很难受</li>
<li>最后决定把需要的部分学会<ul>
<li>线条, 形(结构), 透视, 阴影(光影)</li>
<li>五官, 头发, 四肢, 人体</li>
</ul>
</li>
<li>对应的练习为<ul>
<li>握笔姿势, 矩形练习, 无穷符号练习</li>
<li>立方体,</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因为理想很高但是开始学习时却是从最低点开始, 强烈的反差让人很难受, 就会放弃, 所以必须要坚持过最开始的那段曲线<br>另外, <strong>没有体会到画的过程的开心</strong>, 只想象出了画完后的开心, 所以即使一直想要却潜意识里拒绝, 以以前练习的方法也很难找到<strong>乐趣</strong></p>
<p>尽管绘画水平看起来很有层次, 但是要找到学习的步骤方法实在很难, 因为要完成一个作品无论是线条透视光影都会涉及, 这是一个综合的过程, 所以报班是<strong>肯定</strong>会报的🙂, 就在实习后买了 iPad pro 吧, 关于选择应该是看明年 3 月 ipad pro 2020 版 (原本应该 19 年 9 月出的) 再最终决定, 现在大概是美版或国行二手里 64g 11 寸吧</p>
<p><strong>先干掉想一个劲看直播的心, NO LIVE STREAMING ! 把时间空出来</strong></p>
<p><strong>练习只能增加一定的效率, 理解能大幅增加水平和效率</strong></p>
<p>因为每一步都只知道名字, 例如练习线条, 透视, 形状, 光影等却不知道每一步骤中都有哪些小步骤, 这些小步骤又有什么应用 (学习里对知识点的定义方法), 也就是同一种东西, 有不同的画法, <strong>不同的实践方式</strong></p>
<p><strong>19.12.19</strong> - 根据<a href="https://space.bilibili.com/301570/video" target="_blank" rel="noopener">b站</a>上的来, 先从最喜欢的人入手, 通过一个整体的项目来学习基础, 毕竟画线, 光影什么的都知道是什么概念, 也就没必要先了解只需要知道如何呈现效果, 辅助就是那本<a href="https://book.douban.com/subject/34884825/" target="_blank" rel="noopener">素描书</a>, 把两个都学完, 边学边考虑。然后是<strong>定量</strong>, 首先是都要画一遍的, 也就是书里涉及的内容, 同时有针对性大量练习, <strong>不断理解原理确立目标还有改进练习方法</strong></p>
<ul>
<li>头部结构</li>
<li>五官</li>
<li>头发, 此时可以画头部的线稿</li>
<li>身体整体结构</li>
<li>人体动态和重心</li>
<li>四肢</li>
<li>服装和人体的关系</li>
<li>手脚, 此时可以画人物的线稿</li>
<li>颜色</li>
<li>物件和场景</li>
<li>动物</li>
<li>人物互动和好看动作</li>
<li>镜头与故事性</li>
</ul>
<p><strong>19.12.21</strong> - youtube learntodraw/ 太基础了, 感觉没用</p>
<ul>
<li>tools and shadow</li>
<li>break object to basic shape</li>
<li>shadow</li>
</ul>
<p>后期板绘的时候找3d模型软件来各种针对性练习 (daz studio, Pofi 无限人偶)</p>
<h2 id="学习流程"><a href="#学习流程" class="headerlink" title="学习流程"></a>学习流程</h2><h3 id="起形"><a href="#起形" class="headerlink" title="起形"></a>起形</h3><ul>
<li>用几何法画水壶, 苹果, 香蕉</li>
</ul>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ol>
<li>临摹: 学习的不是最终完成的那幅画, 而是画的过程, 明确练习的目标</li>
<li>速写默写</li>
</ol>
<h3 id="临摹"><a href="#临摹" class="headerlink" title="临摹"></a>临摹</h3><h3 id="审美提高"><a href="#审美提高" class="headerlink" title="审美提高"></a>审美提高</h3><h2 id="能力分类进阶"><a href="#能力分类进阶" class="headerlink" title="能力分类进阶"></a>能力分类进阶</h2><ol>
<li>单色基础</li>
<li>色彩能力</li>
<li>创作能力</li>
</ol>
<blockquote>
<p>技术 = 理解 x 练习量</p>
</blockquote>
<h3 id="单色基础"><a href="#单色基础" class="headerlink" title="单色基础"></a>单色基础</h3><ul>
<li><p>线条</p>
<ul>
<li><strong>线条的作用</strong>: 勾勒形状, 打上光影, 体现质感</li>
<li><strong>线条控制标准</strong><ul>
<li>长短</li>
<li>粗细</li>
<li>稳定, 平直</li>
<li>线与线的距离, 位置</li>
</ul>
</li>
<li><strong>如何练习</strong><ul>
<li>掌握持笔姿势, 发力点 (食指竖, 手腕横), 可以转画布</li>
<li>直线: 矩形直线法, 中间轻两头重</li>
<li>圆弧: 椭圆与无穷符号<blockquote>
<p><a href="https://www.lanqb.com/news/214.html" target="_blank" rel="noopener">常见线条问题解析</a><br><a href="https://www.zhihu.com/question/46946705" target="_blank" rel="noopener">手绘初学者如何排出高逼格的线？</a><br>非常棒😊 =&gt; <a href="https://baijiahao.baidu.com/s?id=1600673122727482953" target="_blank" rel="noopener">自动铅笔排线示范</a><br><a href="https://www.zhihu.com/question/27177194/answer/86428548" target="_blank" rel="noopener">手绘建筑竖线如何画直</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>物体形状, 如何<strong>画得像</strong></p>
<ul>
<li>网格 + 几何 (三角形), 先定出整体的位置坐标, 再几何概括物体的外形特征, 每一次只看一个格子的内容, 找格子中二分三分点</li>
<li>比例, 轮廓, 参照物</li>
<li>体积表现, 用几何体来担任物体的模型, 方便观察记忆刻画结构, <strong>每一次线条的转折都是结构的变化</strong></li>
<li>从整体到细节, <strong>每一个细节都是整体</strong>, 有自己的形状, 体积<blockquote>
<p><a href="https://www.zhihu.com/question/59080170/answer/383149023" target="_blank" rel="noopener">如何提高素描起型</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>透视<ul>
<li>一点透视: 单个消失点, 墙壁等辅助线延长汇聚为一个消失点</li>
<li>两点, 三点: 其实就是不同视角, 平视, 斜视, 俯视</li>
<li>表现方法<ul>
<li>强化消失线: 相交的斜线引导着方向</li>
<li>边缘叠压: 遮挡住其他物体</li>
<li>虚实对比: 清晰与模糊对比产生空间感</li>
</ul>
</li>
<li>圆形透视规律: 近大远小, 越远越圆</li>
</ul>
</li>
<li>光影模型<ul>
<li>受光部, 背光部</li>
<li>亮面, 暗面, 灰面</li>
<li>高光, 灰面, 明暗交界面, 反光, 投影</li>
</ul>
</li>
<li>质感<ul>
<li>外轮廓, 颜色深浅, 肌理</li>
</ul>
</li>
</ul>
<blockquote>
<p>这个公众号讲的非常好 - <a href="https://mp.weixin.qq.com/s/UVFI_CZ0_D4Ujs3R8rUNKA" target="_blank" rel="noopener">素描入门13课视频详解</a><br>这个也行 - <a href="https://www.bilibili.com/read/cv240863/" target="_blank" rel="noopener">越来越多的人放弃了自学画画，因为他们没看过这个！</a></p>
</blockquote>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/12/09/用python考ccf记录/">用 python 考 ccf 记录</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-09
          </time>
          <div class="content"><ul>
<li>网站入口是 <a href="http://cspro.org/" target="_blank" rel="noopener">http://cspro.org/</a></li>
<li>报名用的团队报名, 山大团体免费</li>
<li>选定了语言无法更改</li>
<li>提交后需要等好几秒才有结果, 多刷新</li>
<li>提交可以多次, 可以多尝试</li>
<li>python 考试用的是 idle, 里面有文档, 可以 debug, 能缩进</li>
<li>19.12 只有250分 = =</li>
</ul>
<h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><ul>
<li>输入用input(), 输出多个在一行只需要print函数中打逗号, 分割为数组可以用 split</li>
<li>读取输入后转换类型可以用 map 或 list comprehension<blockquote>
<p><a href="https://www.geeksforgeeks.org/python-converting-all-strings-in-list-to-integers/" target="_blank" rel="noopener">all strings to int</a></p>
</blockquote>
</li>
<li>测试的时候 debug 最快知道哪里有问题</li>
<li>注意输入数据是否有误, 与原文中是否一致, 别少了个符号</li>
<li>变量一开始就用题干里的变量名初始化比较好</li>
<li>重复打印直接用 *, 拼接字符串直接用 +</li>
<li>进制转换, ascii 码 int(str, 16), hex, ord</li>
<li>for 循环间隔 n, range(0,x,n)</li>
<li>字符串转数组, list(), 数组转字符串 “”.join</li>
<li>求最后一位, [-1]</li>
<li>四舍五入, ‘%.1f’ % x</li>
</ul>
<blockquote>
<p>为了尽快读懂, 用一定格式将输入与输出列在纸上: 1. 变量名 2. 代表什么内容 3. 满足什么条件<br>编写前, 将样例带着自己的理解在脑内试着运行一遍<br><strong>编写的过程中</strong>, 将需要弄明白的关系列在纸上, <strong>带入实际情况去想!!</strong><br><a href="https://www.luogu.com.cn/blog/bingogyz/xin-ban-pian-fen-dao-lun" target="_blank" rel="noopener">骗分导论</a></p>
</blockquote>
<h3 id="raid5"><a href="#raid5" class="headerlink" title="raid5"></a>raid5</h3><ul>
<li>异或能够用来推测信息, a⊕b⊕a=b交换a，b值</li>
<li>硬盘内部数据是如何划分的</li>
<li>raid5 校验盘与数据盘是如何摆放的</li>
<li>数学关系到代码上映射是否正确无误</li>
</ul>
<blockquote>
<p>如果出现以下分数对应的可能有:</p>
<ul>
<li>50, 某个比较重要的条件没考虑到, 可能是输入上的问题</li>
<li>80, 大概率没问题, 但是对于特定的一些关系/情况会不过关</li>
</ul>
</blockquote>
<p>10<br>9+3+4x3<br>5+4x5x5<br>7-9-9+8<br>5x6/5x4<br>3+5+7+9<br>1x1+ 9-9<br>1x9-5/9<br>8/5 + 6 * 95 x7-3x66 x4 + 4/5</p>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/11/26/时间安排/">时间安排</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-26
          </time>
          <div class="content"><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>首要任务: hexo-history<br>然后: hexo, pug 等博客设计相关</p>
<p>完成顺序无特别注意不分先后</p>
<ol start="0">
<li>文章内容组织和博客内容划分</li>
<li>jquery plugin</li>
<li>promise, promise 中的异常处理<ul>
<li><a href="http://jamesknelson.com/are-es6-promises-swallowing-your-errors/" target="_blank" rel="noopener"> promise error swallowed</a><ul>
<li>logger, this.log is not a function</li>
</ul>
</li>
<li><a href="https://zellwk.com/blog/async-await-in-loops/" target="_blank" rel="noopener">await in loop</a></li>
<li><a href="https://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop" target="_blank" rel="noopener">map, for await</a></li>
<li>async cancel, 程序仍在运行的原因</li>
<li>HTTP 常见错误<ul>
<li><a href="https://juejin.im/post/5de0ddbf51882523467752b8" target="_blank" rel="noopener">ECONNRESET VS ETIMEDOUT</a></li>
</ul>
</li>
<li><a href="https://segmentfault.com/a/1190000014926921" target="_blank" rel="noopener">nodejs真的是单线程吗？</a></li>
<li><a href="https://cnodejs.org/topic/555963317cabb7b45ee6be67" target="_blank" rel="noopener">nodejs 内存同步</a></li>
<li><a href="https://lz5z.com/%E7%9C%9F-Node%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">真-Node多线程</a></li>
<li><a href="https://www.zhihu.com/question/54137163" target="_blank" rel="noopener">js是单线程的，setimeout计时是什么来执行？</a></li>
<li>有争议:<a href="https://juejin.im/post/5b1e55cbe51d45067e6fcb84" target="_blank" rel="noopener">什么东西会占线程池</a><ul>
<li><a href="https://stackoverflow.com/questions/22644328/when-is-the-thread-pool-used" target="_blank" rel="noopener">when is thread pool used</a></li>
</ul>
</li>
</ul>
</li>
<li>源码分析</li>
<li>算法</li>
<li>打字动画效果</li>
<li>数据结构与算法设计 2020.3 之前</li>
<li>hexo-history</li>
</ol>
</div>
          <hr>
        </div>
        <div class="recent-post-item article-container"><a class="article-title" href="/2019/11/26/数据结构与算法设计/">数据结构与算法</a>
          <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-26
          </time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/总结/">总结</a></span>
          <div class="content"><p>解决问题的流程称为算法, 数据结构是这个过程中的一环<br>仅总结, 不分析, 通过学习别人制造体系, 收集遇到的来丰富</p>
<p>收集:</p>
<ul>
<li><a href="https://oi-wiki.org/ds/monotonous-stack/" target="_blank" rel="noopener">OI wiki</a></li>
<li>wikipedia, 深入了解直接搜, 超详细, 引用也很有用, 但是中文版没有英文版详细</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="学习流程"><a href="#学习流程" class="headerlink" title="学习流程:"></a>学习流程:</h3><ol>
<li>结构定义<br><a href="https://www.tutorialspoint.com/data_structures_algorithms" target="_blank" rel="noopener">tutorialspoint</a></li>
<li>基本操作方法, 一般与上方在一块</li>
<li>学习(读懂)<br>语言: <a href="https://www.tutorialspoint.com/python_data_structure" target="_blank" rel="noopener">python</a></li>
<li>考察, online judge problem set<br><a href="https://leetcode-cn.com/explore/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://practice.geeksforgeeks.org/" target="_blank" rel="noopener">Geeksforgeek</a></li>
<li>经典应用与cs方面的应用, serach google<br>application of xxx / real life use of xxx</li>
<li>将来碰到了有趣的应用也会收集在这</li>
</ol>
<p>最基本的考察: 创建, 展示(遍历), 插入, 删除, 查询, 更改。所以不会再包含</p>
<blockquote>
<p>如何读懂: 提取核心算法, 使用实际数据脑中执行一遍, 作图辅助, 熟悉相关基础</p>
</blockquote>
<p>与内存直接挂钩的数据结构和抽象使用的数据结构</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>Simple Linked List</li>
<li>Doubly Linked List</li>
<li>Circular Linked List</li>
<li>Circular Doubly Linked List</li>
<li>跳跃表</li>
</ol>
<p>考察:</p>
<ol>
<li>链表反转</li>
</ol>
<p>链表的应用:</p>
<h4 id="in-computer-science"><a href="#in-computer-science" class="headerlink" title="in computer science"></a>in computer science</h4><ol>
<li>可以实现堆栈与队列</li>
<li>实现邻接图</li>
<li>[跳跃表]二分搜索</li>
</ol>
<h4 id="in-real-world"><a href="#in-real-world" class="headerlink" title="in real world"></a>in real world</h4><ol>
<li>image viewer - 前进和后退</li>
<li>music player</li>
</ol>
<p><a href="https://www.geeksforgeeks.org/applications-of-linked-list-data-structure/" target="_blank" rel="noopener">Applications of linked list data structure</a></p>
<h3 id="堆栈和队列"><a href="#堆栈和队列" class="headerlink" title="堆栈和队列"></a>堆栈和队列</h3><ol>
<li>stack</li>
<li>queue</li>
<li>单调栈</li>
<li>优先队列</li>
</ol>
<h4 id="cs"><a href="#cs" class="headerlink" title="cs"></a>cs</h4><ol>
<li>prefix, postfix notation (波兰表达式)<br>中缀适合人类读</li>
<li>syntax parsing</li>
<li>backtracking, 图的搜索</li>
<li>function call</li>
<li>[单调栈] 查询区间最值, 第k个xxx, 出现于动规</li>
<li>[stack] DFS, [queue] BFS</li>
</ol>
<p><a href="https://www.thecrazyprogrammer.com/2016/04/applications-of-stack.html" target="_blank" rel="noopener">Applications of Stack</a></p>
<h4 id="real"><a href="#real" class="headerlink" title="real"></a>real</h4><ol>
<li>undo/redo operation</li>
<li>缓冲区</li>
</ol>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol>
<li>tree</li>
<li>Binary Search Tree</li>
<li>AVL Tree</li>
<li>Spanning Tree 生成树</li>
<li>Heap</li>
</ol>
<p>考察:</p>
<ol>
<li>遍历, 前中后</li>
<li>树的高度</li>
<li>AVL平衡旋转</li>
</ol>
<h4 id="cs-1"><a href="#cs-1" class="headerlink" title="cs"></a>cs</h4><ol>
<li>Minimum Spanning-Tree Algorithm =&gt; Kruskal and Prim</li>
<li>Heap sort</li>
<li>[Heap] prior queue</li>
</ol>
<h4 id="real-1"><a href="#real-1" class="headerlink" title="real"></a>real</h4><ol>
<li>[spanning Tree] 路由协议</li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ol>
<li>邻接矩阵</li>
<li>邻接表</li>
</ol>
<p>考察:</p>
<ol>
<li>深度优先</li>
<li>广度优先</li>
<li>最短路径 - Dijkstra, Floyd</li>
</ol>
<h4 id="cs-2"><a href="#cs-2" class="headerlink" title="cs"></a>cs</h4><ol>
<li>database ER diagram</li>
</ol>
<h4 id="real-2"><a href="#real-2" class="headerlink" title="real"></a>real</h4><ol>
<li>route</li>
</ol>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ol>
<li>哈希数组</li>
</ol>
<p>考察:</p>
<ol>
<li>哈希碰撞 - 线性检测, Separate chaining</li>
</ol>
<h4 id="cs-3"><a href="#cs-3" class="headerlink" title="cs"></a>cs</h4><ol>
<li>对象,  HashMap in java, dict in python, js 的 object 在v8 里不是 hash, 是由静态类生成的 - <a href="https://stackoverflow.com/questions/6586670/how-does-javascript-vm-implements-object-property-access-is-it-hashtable" target="_blank" rel="noopener">How does JavaScript VM implements Object property access? Is it Hashtable?
</a></li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>流程</strong>: 设计, 分析, 实现, 试验, 改进</p>
<blockquote>
<p>设计: 选用 DS, 算法<br>实现: 使用语言特性<br>改进: 根据性能和 debug 改善代码</p>
</blockquote>
<p>算法可以归类为: DS相关 (如上), 应用场景 (排序, 字符串, 图, 查找), 设计方法 (动规, 贪心, 回溯, 分治, 枚举)</p>
<h3 id="学习流程-1"><a href="#学习流程-1" class="headerlink" title="学习流程:"></a>学习流程:</h3><ol>
<li>针对问题场景</li>
<li>基本流程和时间空间复杂度 - 部分添加参考引用</li>
<li>将自己的理解输出, 编程实现, 再学习最佳实践</li>
<li>考察, 总结使用这个算法的问题的特点</li>
</ol>
<blockquote>
<p>原始算法存在多个改进版本, 这里并不会介绍, 但是如果有需要会将来另开篇文章总结</p>
</blockquote>
<h3 id="算法与内存-cpu"><a href="#算法与内存-cpu" class="headerlink" title="算法与内存, cpu"></a>算法与内存, cpu</h3><ol>
<li>根据 cpu 缓存命中算法, 取数据尽量是在一块  - 堆排序</li>
<li>数组在内存中是一块连续的空间, 如果过大, 很难找到<h3 id="如何衡量"><a href="#如何衡量" class="headerlink" title="如何衡量"></a>如何衡量</h3></li>
</ol>
<p>时间复杂度分析:</p>
<ul>
<li><strong>渐近符号记法</strong>: 考察输入值大小趋近无穷, 不包括这个函数的低阶项和首项系数<br>O: 运行时间的渐近上界<br>Ω: 运行时间的渐近下界<br>Θ: 运行时间的渐近确界<blockquote>
<p>算法时间复杂度用 O 表示, 最坏不会超过 (<strong>不研究了, 反正也没什么大用</strong>)</p>
</blockquote>
</li>
<li><strong>问题规模</strong>: 输入数据的大小 n<br>时间复杂度: T(n)=O(f(n)), f(n)=2n^2+1^,O(f(n))=O(n^2^)</li>
<li><strong>主定理</strong>: 奠定算法分析尤其是递归算法的理论基石<blockquote>
<p>根据递推关系式中的f(n)来推导时间复杂度T(n)<br><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">主定理</a><br><a href="http://blog.lirui.me/posts/d53d7104/#%E7%94%A8%E4%B8%BB%E5%AE%9A%E7%90%86%E6%90%9E%E4%BA%8B%E6%83%85" target="_blank" rel="noopener">用主定理搞事情</a></p>
</blockquote>
</li>
</ul>
<p><strong>从代码计算时间复杂度</strong> - 根据代码中的循环操作转换为变量为 n 的函数</p>
<p><strong>从设计计算时间复杂度</strong> - 分成步骤, 合并步骤中每个元素执行次数</p>
<blockquote>
<p><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">算法与数据结构之间的比较</a><br><a href="http://aillieo.cn/post/2017-01-09-algorithm-complexity-cheatsheet/" target="_blank" rel="noopener">常见算法复杂度Cheatsheet</a></p>
</blockquote>
<p><img src="/image/algorithm_time_complexity.png" alt=" 算法时间复杂度比较 "></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><strong>原地</strong>: 排序时只有常数个元素需要存储在数组之外<br><strong>稳定</strong>: 排序后不改变相同数值的相关位置<br><strong>自适应</strong>: 排序时不再排序原数组中已经排序好的部分<br><strong>基于比较</strong>: 排序时通过比较大小来进行操作</p>
<blockquote>
<p>通过交换相邻元素来进行排序的任何算法都需要Ο(n<sup>2</sup>)的时间, 因为一次最多只能消除一个逆序,<br>O(nlogn)是基于比较的排序算法的时间复杂度下界<br><a href="https://aojueliuyun.github.io/2018/03/24/2018.3.26--efficient-sort-algorithms/" target="_blank" rel="noopener">高效排序算法——希尔排序、堆排序、归并排序、快速排序</a><br><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting algorithm</a></p>
</blockquote>
<h4 id="最差时间-Ο-n2"><a href="#最差时间-Ο-n2" class="headerlink" title="最差时间 Ο(n2)"></a>最差时间 Ο(n<sup>2</sup>)</h4><ol>
<li>冒泡 - 原地, 基于比较</li>
<li>插入 - 原地, 基于比较</li>
<li>选择 - 原地, 基于比较</li>
</ol>
<blockquote>
<p>插入排序可以避免已经排序好的数组再次重新比较 (最佳O(n)), 但是每一次交换都需要三次赋值操作, 所以反而会比选择排序耗费时间更长 - <a href="https://blog.csdn.net/qq_19782019/article/details/78021705" target="_blank" rel="noopener">插入排序与选择排序的比较</a></p>
</blockquote>
<h4 id="最差时间-Ο-n-log-n"><a href="#最差时间-Ο-n-log-n" class="headerlink" title="最差时间 Ο(n log n)"></a>最差时间 Ο(n log n)</h4><p>没有基于比较的排序算法能比其快, 只有依赖输入为特殊性质的排序算法能超过它们</p>
<p>1.<strong>归并 - 基于分治技术</strong><br>可以使用多个 cpu 来执行</p>
<blockquote>
<p><strong>递归划分数组</strong> - logn, 2<sup>k</sup> = n<br><strong>数组排序</strong> - n, 利用已排序好的性质通过比较放入额外创建的数组中<br>合并一下: n*(logn + 1/2logn + …) &lt;= 2nlogn</p>
</blockquote>
<ol start="2">
<li><strong>快排</strong></li>
</ol>
<p>由冒泡排序进行改进</p>
<blockquote>
<p><strong>选取pivot划分数组</strong> - 假设每次都选的好正好分一半, <strong>logn</strong>, 选得不好比如说正好是逆序, 那么就会是 n<br><strong>排序</strong> - 一遍循环, 将大于pivot和小于pivot的调换位置, 直到两个指针相遇, <strong>n</strong><br>合并的话就是 <strong>nlogn</strong>, 当然对于这些典型的递归算法也可以用主定理来解 - <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#%E6%AD%A3%E8%A6%8F%E5%88%86%E6%9E%90" target="_blank" rel="noopener">wiki-快速排序</a></p>
</blockquote>
<p>没有优化重复元素(三向切分快排)比不过希尔排序、堆排序和归并排序</p>
<ol start="3">
<li><strong>堆</strong><br>提升版的选择排序, 在实际运行时, 由于计算机cpu缓存命中的缘故不如提升版的快排(局部性)</li>
</ol>
<blockquote>
<p><strong>将数组转换为堆</strong> - n<br><strong>循环取出第一个元素并维护优先队列</strong> - nlogn, 维护的时间复杂度为 logn<br>合并: n + nlogn =&gt; nlogn<br><a href="https://en.wikipedia.org/wiki/Heapsort#Algorithm" target="_blank" rel="noopener">Heapsort</a><br><a href="https://www.zhihu.com/question/23873747/answer/327295185" target="_blank" rel="noopener">为什么在平均情况下快速排序比堆排序要优秀？</a></p>
</blockquote>
<p> 在语言内部的排序算法中, 会根据数组的长度等信息选择不同的排序算法, 一般来说经过多重优化, 比自己实现的效率会高不少</p>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>基数, 希尔, 桶</p>
<ol>
<li><strong>希尔 - 基于插入排序, 最优可达n<sup>4/3</sup></strong></li>
</ol>
<p>第一批冲破 o(n<sup>2</sup>) 的算法。选择希尔增量依照最原始为n/2, 按照大小将数组分组, 每组进行插入排序, 将增量依次除2并排序直到1, 最后一次执行完插入排序后, 此时数组有序</p>
<blockquote>
<p><strong>依照希尔序列划分数组</strong>: logn<br><strong>每次进行插入排序</strong>: 最好 - n, 最坏 - n<sup>2</sup>, 因为每次都将较远的逆序对消除, 不会有最坏出现 - 由于希尔排序数学分析较难, 这里没有给出合并<br><a href="https://www.zhihu.com/question/24637339" target="_blank" rel="noopener">希尔排序为什么会那么牛那么快，能够证明吗？</a><br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>
</blockquote>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>基于分治思想, 在有序数组上执行</p>
<blockquote>
<p><strong>将数组不断中值划分比较</strong> - logn<br>在求 mid 索引的时候, 为了避免数组超过 int 范围, 使用这种写法: mid = low + (high - low) / 2</p>
</blockquote>
<h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>在二分的方法上改进过来的, 只不过二分猜测值的位置在中间, 插值猜测值的位置由插值公式给出, 公式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left + <span class="built_in">parseInt</span>(( key - data[left] ) / ( data[right] - data[left] ))*( right - left )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复杂度为o(log(logn)), 可以看看这个 <a href="http://www.cs.technion.ac.il/~itai/publications/Algorithms/p550-perl.pdf" target="_blank" rel="noopener">paper</a>, 对目前的我没什么大用, 姑且留个记号</p>
</blockquote>
<h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><p>根据哈希数据结构而来, 时间复杂度为 O(1)</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>// TODO 2020.3 之前</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><h4 id="shuffle-洗牌"><a href="#shuffle-洗牌" class="headerlink" title="shuffle 洗牌"></a>shuffle 洗牌</h4></div>
          <hr>
        </div>
        <nav id="pagination">
          <div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a>
          </div>
        </nav>
      </div>
    </div>
    <footer class="footer-bg" style="background-image: url(http://img.luckyray.cn/896653.jpg)">
      <div class="layout" id="footer">
        <div class="copyright">&copy;2019 - 2020 By null</div>
        <div class="framework-info"><span>驱动 - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="#"><span>diary</span></a></div>
      </div>
    </footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i>
    <script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script>
    <script src="/js/utils.js?version=1.6.1"></script>
    <script src="/js/fancybox.js?version=1.6.1"></script>
    <script src="/js/sidebar.js?version=1.6.1"></script>
    <script src="/js/copy.js?version=1.6.1"></script>
    <script src="/js/fireworks.js?version=1.6.1"></script>
    <script src="/js/transition.js?version=1.6.1"></script>
    <script src="/js/scroll.js?version=1.6.1"></script>
    <script src="/js/head.js?version=1.6.1"></script>
    <script>
      if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
        $('#nav').addClass('is-mobile')
        $('footer').addClass('is-mobile')
      }
    </script>
  </body>
</html>