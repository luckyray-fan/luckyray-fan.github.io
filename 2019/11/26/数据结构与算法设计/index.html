<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="数据结构与算法">
    <meta name="keywords" content="总结">
    <meta name="author">
    <meta name="copyright">
    <title>数据结构与算法 | luckyray</title><link rel="shortcut icon" href="/favicons.ico">
    <link rel="stylesheet" href="/css/index.css?version=1.6.1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1">
    <link rel="dns-prefetch" href="https://cdn.staticfile.org">
    <link rel="dns-prefetch" href="https://cdn.bootcss.com">
    <link rel="dns-prefetch" href="https://creativecommons.org">
    <script>
      var GLOBAL_CONFIG = {
        root: '/',
        algolia: undefined,
        localSearch: undefined,
        copy: {
          success: '复制成功',
          error: '复制错误',
          noSupport: '浏览器不支持'
        }
      }
    </script>
  </head>
  <body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i>
    <div id="sidebar">
      <div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span>
        <hr>
      </div>
      <div class="sidebar-toc">
        <div class="sidebar-toc__title">目录</div>
        <div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span>
          <div class="sidebar-toc__progress-bar"></div>
        </div>
        <div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#学习流程"><span class="toc-number">1.1.</span> <span class="toc-text">学习流程:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">1.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#in-computer-science"><span class="toc-number">1.2.1.</span> <span class="toc-text">in computer science</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#in-real-world"><span class="toc-number">1.2.2.</span> <span class="toc-text">in real world</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆栈和队列"><span class="toc-number">1.3.</span> <span class="toc-text">堆栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cs"><span class="toc-number">1.3.1.</span> <span class="toc-text">cs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#real"><span class="toc-number">1.3.2.</span> <span class="toc-text">real</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树"><span class="toc-number">1.4.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cs-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">cs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#real-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">real</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图"><span class="toc-number">1.5.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cs-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">cs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#real-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">real</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表"><span class="toc-number">1.6.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cs-3"><span class="toc-number">1.6.1.</span> <span class="toc-text">cs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">2.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#学习流程-1"><span class="toc-number">2.1.</span> <span class="toc-text">学习流程:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法与内存-cpu"><span class="toc-number">2.2.</span> <span class="toc-text">算法与内存, cpu</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何衡量"><span class="toc-number">2.3.</span> <span class="toc-text">如何衡量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">2.4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最差时间-Ο-n2"><span class="toc-number">2.4.1.</span> <span class="toc-text">最差时间 Ο(n2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最差时间-Ο-n-log-n"><span class="toc-number">2.4.2.</span> <span class="toc-text">最差时间 Ο(n log n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#杂项"><span class="toc-number">2.4.3.</span> <span class="toc-text">杂项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找"><span class="toc-number">2.5.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二分"><span class="toc-number">2.5.1.</span> <span class="toc-text">二分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插值"><span class="toc-number">2.5.2.</span> <span class="toc-text">插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">2.6.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">2.7.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#双指针"><span class="toc-number">2.7.1.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shuffle-洗牌"><span class="toc-number">2.7.2.</span> <span class="toc-text">shuffle 洗牌</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <div class="author-info hide">
        <div class="author-info__avatar text-center"><img src="/img/avatar.png"></div>
        <div class="author-info__name text-center"></div>
        <div class="author-info__description text-center">只能自己努力找乐子了</div>
        <hr>
        <div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a>
        </div>
      </div>
    </div>
    <div id="content-outer">
      <div id="top-container" style="background-image: url(http://img.luckyray.cn/896653.jpg)">
        <div id="page-header"><span class="pull-left"> <a id="site-name" href="/">luckyray</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div>
        <div id="post-info">
          <div id="post-title">数据结构与算法</div>
          <div id="post-meta">
            <time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-26
            </time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法/">算法</a>
          </div>
        </div>
      </div>
      <div class="layout" id="content-inner">
        <article id="post">
          <div class="article-container" id="post-content"><p>解决问题的流程称为算法, 数据结构是这个过程中的一环<br>仅总结, 不分析, 通过学习别人制造体系, 收集遇到的来丰富</p>
<p>收集:</p>
<ul>
<li><a href="https://oi-wiki.org/ds/monotonous-stack/" target="_blank" rel="noopener">OI wiki</a></li>
<li>wikipedia, 深入了解直接搜, 超详细, 引用也很有用, 但是中文版没有英文版详细</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="学习流程"><a href="#学习流程" class="headerlink" title="学习流程:"></a>学习流程:</h3><ol>
<li>结构定义<br><a href="https://www.tutorialspoint.com/data_structures_algorithms" target="_blank" rel="noopener">tutorialspoint</a></li>
<li>基本操作方法, 一般与上方在一块</li>
<li>学习(读懂)<br>语言: <a href="https://www.tutorialspoint.com/python_data_structure" target="_blank" rel="noopener">python</a></li>
<li>考察, online judge problem set<br><a href="https://leetcode-cn.com/explore/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://practice.geeksforgeeks.org/" target="_blank" rel="noopener">Geeksforgeek</a></li>
<li>经典应用与cs方面的应用, serach google<br>application of xxx / real life use of xxx</li>
<li>将来碰到了有趣的应用也会收集在这</li>
</ol>
<p>最基本的考察: 创建, 展示(遍历), 插入, 删除, 查询, 更改。所以不会再包含</p>
<blockquote>
<p>如何读懂: 提取核心算法, 使用实际数据脑中执行一遍, 作图辅助, 熟悉相关基础</p>
</blockquote>
<p>与内存直接挂钩的数据结构和抽象使用的数据结构</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>Simple Linked List</li>
<li>Doubly Linked List</li>
<li>Circular Linked List</li>
<li>Circular Doubly Linked List</li>
<li>跳跃表</li>
</ol>
<p>考察:</p>
<ol>
<li>链表反转</li>
</ol>
<p>链表的应用:</p>
<h4 id="in-computer-science"><a href="#in-computer-science" class="headerlink" title="in computer science"></a>in computer science</h4><ol>
<li>可以实现堆栈与队列</li>
<li>实现邻接图</li>
<li>[跳跃表]二分搜索</li>
</ol>
<h4 id="in-real-world"><a href="#in-real-world" class="headerlink" title="in real world"></a>in real world</h4><ol>
<li>image viewer - 前进和后退</li>
<li>music player</li>
</ol>
<p><a href="https://www.geeksforgeeks.org/applications-of-linked-list-data-structure/" target="_blank" rel="noopener">Applications of linked list data structure</a></p>
<h3 id="堆栈和队列"><a href="#堆栈和队列" class="headerlink" title="堆栈和队列"></a>堆栈和队列</h3><ol>
<li>stack</li>
<li>queue</li>
<li>单调栈</li>
<li>优先队列</li>
</ol>
<h4 id="cs"><a href="#cs" class="headerlink" title="cs"></a>cs</h4><ol>
<li>prefix, postfix notation (波兰表达式)<br>中缀适合人类读</li>
<li>syntax parsing</li>
<li>backtracking, 图的搜索</li>
<li>function call</li>
<li>[单调栈] 查询区间最值, 第k个xxx, 出现于动规</li>
<li>[stack] DFS, [queue] BFS</li>
</ol>
<p><a href="https://www.thecrazyprogrammer.com/2016/04/applications-of-stack.html" target="_blank" rel="noopener">Applications of Stack</a></p>
<h4 id="real"><a href="#real" class="headerlink" title="real"></a>real</h4><ol>
<li>undo/redo operation</li>
<li>缓冲区</li>
</ol>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol>
<li>tree</li>
<li>Binary Search Tree</li>
<li>AVL Tree</li>
<li>Spanning Tree 生成树</li>
<li>Heap</li>
</ol>
<p>考察:</p>
<ol>
<li>遍历, 前中后</li>
<li>树的高度</li>
<li>AVL平衡旋转</li>
</ol>
<h4 id="cs-1"><a href="#cs-1" class="headerlink" title="cs"></a>cs</h4><ol>
<li>Minimum Spanning-Tree Algorithm =&gt; Kruskal and Prim</li>
<li>Heap sort</li>
<li>[Heap] prior queue</li>
</ol>
<h4 id="real-1"><a href="#real-1" class="headerlink" title="real"></a>real</h4><ol>
<li>[spanning Tree] 路由协议</li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ol>
<li>邻接矩阵</li>
<li>邻接表</li>
</ol>
<p>考察:</p>
<ol>
<li>深度优先</li>
<li>广度优先</li>
<li>最短路径 - Dijkstra, Floyd</li>
</ol>
<h4 id="cs-2"><a href="#cs-2" class="headerlink" title="cs"></a>cs</h4><ol>
<li>database ER diagram</li>
</ol>
<h4 id="real-2"><a href="#real-2" class="headerlink" title="real"></a>real</h4><ol>
<li>route</li>
</ol>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ol>
<li>哈希数组</li>
</ol>
<p>考察:</p>
<ol>
<li>哈希碰撞 - 线性检测, Separate chaining</li>
</ol>
<h4 id="cs-3"><a href="#cs-3" class="headerlink" title="cs"></a>cs</h4><ol>
<li>对象,  HashMap in java, dict in python, js 的 object 在v8 里不是 hash, 是由静态类生成的 - <a href="https://stackoverflow.com/questions/6586670/how-does-javascript-vm-implements-object-property-access-is-it-hashtable" target="_blank" rel="noopener">How does JavaScript VM implements Object property access? Is it Hashtable?
</a></li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>流程</strong>: 设计, 分析, 实现, 试验, 改进</p>
<blockquote>
<p>设计: 选用 DS, 算法<br>实现: 使用语言特性<br>改进: 根据性能和 debug 改善代码</p>
</blockquote>
<p>算法可以归类为: DS相关 (如上), 应用场景 (排序, 字符串, 图, 查找), 设计方法 (动规, 贪心, 回溯, 分治, 枚举)</p>
<h3 id="学习流程-1"><a href="#学习流程-1" class="headerlink" title="学习流程:"></a>学习流程:</h3><ol>
<li>针对问题场景</li>
<li>基本流程和时间空间复杂度 - 部分添加参考引用</li>
<li>将自己的理解输出, 编程实现, 再学习最佳实践</li>
<li>考察, 总结使用这个算法的问题的特点</li>
</ol>
<blockquote>
<p>原始算法存在多个改进版本, 这里并不会介绍, 但是如果有需要会将来另开篇文章总结</p>
</blockquote>
<h3 id="算法与内存-cpu"><a href="#算法与内存-cpu" class="headerlink" title="算法与内存, cpu"></a>算法与内存, cpu</h3><ol>
<li>根据 cpu 缓存命中算法, 取数据尽量是在一块  - 堆排序</li>
<li>数组在内存中是一块连续的空间, 如果过大, 很难找到<h3 id="如何衡量"><a href="#如何衡量" class="headerlink" title="如何衡量"></a>如何衡量</h3></li>
</ol>
<p>时间复杂度分析:</p>
<ul>
<li><strong>渐近符号记法</strong>: 考察输入值大小趋近无穷, 不包括这个函数的低阶项和首项系数<br>O: 运行时间的渐近上界<br>Ω: 运行时间的渐近下界<br>Θ: 运行时间的渐近确界<blockquote>
<p>算法时间复杂度用 O 表示, 最坏不会超过 (<strong>不研究了, 反正也没什么大用</strong>)</p>
</blockquote>
</li>
<li><strong>问题规模</strong>: 输入数据的大小 n<br>时间复杂度: T(n)=O(f(n)), f(n)=2n^2+1^,O(f(n))=O(n^2^)</li>
<li><strong>主定理</strong>: 奠定算法分析尤其是递归算法的理论基石<blockquote>
<p>根据递推关系式中的f(n)来推导时间复杂度T(n)<br><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">主定理</a><br><a href="http://blog.lirui.me/posts/d53d7104/#%E7%94%A8%E4%B8%BB%E5%AE%9A%E7%90%86%E6%90%9E%E4%BA%8B%E6%83%85" target="_blank" rel="noopener">用主定理搞事情</a></p>
</blockquote>
</li>
</ul>
<p><strong>从代码计算时间复杂度</strong> - 根据代码中的循环操作转换为变量为 n 的函数</p>
<p><strong>从设计计算时间复杂度</strong> - 分成步骤, 合并步骤中每个元素执行次数</p>
<blockquote>
<p><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">算法与数据结构之间的比较</a><br><a href="http://aillieo.cn/post/2017-01-09-algorithm-complexity-cheatsheet/" target="_blank" rel="noopener">常见算法复杂度Cheatsheet</a></p>
</blockquote>
<p><img src="/image/algorithm_time_complexity.png" alt=" 算法时间复杂度比较 "></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><strong>原地</strong>: 排序时只有常数个元素需要存储在数组之外<br><strong>稳定</strong>: 排序后不改变相同数值的相关位置<br><strong>自适应</strong>: 排序时不再排序原数组中已经排序好的部分<br><strong>基于比较</strong>: 排序时通过比较大小来进行操作</p>
<blockquote>
<p>通过交换相邻元素来进行排序的任何算法都需要Ο(n<sup>2</sup>)的时间, 因为一次最多只能消除一个逆序,<br>O(nlogn)是基于比较的排序算法的时间复杂度下界<br><a href="https://aojueliuyun.github.io/2018/03/24/2018.3.26--efficient-sort-algorithms/" target="_blank" rel="noopener">高效排序算法——希尔排序、堆排序、归并排序、快速排序</a><br><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting algorithm</a></p>
</blockquote>
<h4 id="最差时间-Ο-n2"><a href="#最差时间-Ο-n2" class="headerlink" title="最差时间 Ο(n2)"></a>最差时间 Ο(n<sup>2</sup>)</h4><ol>
<li>冒泡 - 原地, 基于比较</li>
<li>插入 - 原地, 基于比较</li>
<li>选择 - 原地, 基于比较</li>
</ol>
<blockquote>
<p>插入排序可以避免已经排序好的数组再次重新比较 (最佳O(n)), 但是每一次交换都需要三次赋值操作, 所以反而会比选择排序耗费时间更长 - <a href="https://blog.csdn.net/qq_19782019/article/details/78021705" target="_blank" rel="noopener">插入排序与选择排序的比较</a></p>
</blockquote>
<h4 id="最差时间-Ο-n-log-n"><a href="#最差时间-Ο-n-log-n" class="headerlink" title="最差时间 Ο(n log n)"></a>最差时间 Ο(n log n)</h4><p>没有基于比较的排序算法能比其快, 只有依赖输入为特殊性质的排序算法能超过它们</p>
<p>1.<strong>归并 - 基于分治技术</strong><br>可以使用多个 cpu 来执行</p>
<blockquote>
<p><strong>递归划分数组</strong> - logn, 2<sup>k</sup> = n<br><strong>数组排序</strong> - n, 利用已排序好的性质通过比较放入额外创建的数组中<br>合并一下: n*(logn + 1/2logn + …) &lt;= 2nlogn</p>
</blockquote>
<ol start="2">
<li><strong>快排</strong></li>
</ol>
<p>由冒泡排序进行改进</p>
<blockquote>
<p><strong>选取pivot划分数组</strong> - 假设每次都选的好正好分一半, <strong>logn</strong>, 选得不好比如说正好是逆序, 那么就会是 n<br><strong>排序</strong> - 一遍循环, 将大于pivot和小于pivot的调换位置, 直到两个指针相遇, <strong>n</strong><br>合并的话就是 <strong>nlogn</strong>, 当然对于这些典型的递归算法也可以用主定理来解 - <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#%E6%AD%A3%E8%A6%8F%E5%88%86%E6%9E%90" target="_blank" rel="noopener">wiki-快速排序</a></p>
</blockquote>
<p>没有优化重复元素(三向切分快排)比不过希尔排序、堆排序和归并排序</p>
<ol start="3">
<li><strong>堆</strong><br>提升版的选择排序, 在实际运行时, 由于计算机cpu缓存命中的缘故不如提升版的快排(局部性)</li>
</ol>
<blockquote>
<p><strong>将数组转换为堆</strong> - n<br><strong>循环取出第一个元素并维护优先队列</strong> - nlogn, 维护的时间复杂度为 logn<br>合并: n + nlogn =&gt; nlogn<br><a href="https://en.wikipedia.org/wiki/Heapsort#Algorithm" target="_blank" rel="noopener">Heapsort</a><br><a href="https://www.zhihu.com/question/23873747/answer/327295185" target="_blank" rel="noopener">为什么在平均情况下快速排序比堆排序要优秀？</a></p>
</blockquote>
<p> 在语言内部的排序算法中, 会根据数组的长度等信息选择不同的排序算法, 一般来说经过多重优化, 比自己实现的效率会高不少</p>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>基数, 希尔, 桶</p>
<ol>
<li><strong>希尔 - 基于插入排序, 最优可达n<sup>4/3</sup></strong></li>
</ol>
<p>第一批冲破 o(n<sup>2</sup>) 的算法。选择希尔增量依照最原始为n/2, 按照大小将数组分组, 每组进行插入排序, 将增量依次除2并排序直到1, 最后一次执行完插入排序后, 此时数组有序</p>
<blockquote>
<p><strong>依照希尔序列划分数组</strong>: logn<br><strong>每次进行插入排序</strong>: 最好 - n, 最坏 - n<sup>2</sup>, 因为每次都将较远的逆序对消除, 不会有最坏出现 - 由于希尔排序数学分析较难, 这里没有给出合并<br><a href="https://www.zhihu.com/question/24637339" target="_blank" rel="noopener">希尔排序为什么会那么牛那么快，能够证明吗？</a><br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>
</blockquote>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>基于分治思想, 在有序数组上执行</p>
<blockquote>
<p><strong>将数组不断中值划分比较</strong> - logn<br>在求 mid 索引的时候, 为了避免数组超过 int 范围, 使用这种写法: mid = low + (high - low) / 2</p>
</blockquote>
<h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>在二分的方法上改进过来的, 只不过二分猜测值的位置在中间, 插值猜测值的位置由插值公式给出, 公式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left + <span class="built_in">parseInt</span>(( key - data[left] ) / ( data[right] - data[left] ))*( right - left )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复杂度为o(log(logn)), 可以看看这个 <a href="http://www.cs.technion.ac.il/~itai/publications/Algorithms/p550-perl.pdf" target="_blank" rel="noopener">paper</a>, 对目前的我没什么大用, 姑且留个记号</p>
</blockquote>
<h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><p>根据哈希数据结构而来, 时间复杂度为 O(1)</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>// TODO 2020.3 之前</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><h4 id="shuffle-洗牌"><a href="#shuffle-洗牌" class="headerlink" title="shuffle 洗牌"></a>shuffle 洗牌</h4></div>
        </article>
        <div class="post-copyright">
          <div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined"></a></span></div>
          <div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://luckyray-fan.github.io/2019/11/26/数据结构与算法设计/">https://luckyray-fan.github.io/2019/11/26/数据结构与算法设计/</a></span></div>
          <div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://luckyray-fan.github.io">luckyray</a>！</span></div>
        </div>
        <div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/总结/">总结</a>
        </div>
        <nav id="pagination">
          <div class="prev-post pull-left"><a href="/2019/11/26/时间安排/"><i class="fa fa-chevron-left">  </i><span>时间安排</span></a></div>
          <div class="next-post pull-right"><a href="/2019/11/04/源码分析/"><span>源码分析</span><i class="fa fa-chevron-right"></i></a></div>
        </nav>
      </div>
    </div>
    <footer class="footer-bg" style="background-image: url(http://img.luckyray.cn/896653.jpg)">
      <div class="layout" id="footer">
        <div class="copyright">&copy;2019 - 2020 By null</div>
        <div class="framework-info"><span>驱动 - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="#"><span>diary</span></a></div>
      </div>
    </footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i>
    <script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script>
    <script src="/js/utils.js?version=1.6.1"></script>
    <script src="/js/fancybox.js?version=1.6.1"></script>
    <script src="/js/sidebar.js?version=1.6.1"></script>
    <script src="/js/copy.js?version=1.6.1"></script>
    <script src="/js/fireworks.js?version=1.6.1"></script>
    <script src="/js/transition.js?version=1.6.1"></script>
    <script src="/js/scroll.js?version=1.6.1"></script>
    <script src="/js/head.js?version=1.6.1"></script>
    <script>
      if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
        $('#nav').addClass('is-mobile')
        $('footer').addClass('is-mobile')
      }
    </script>
  </body>
</html>